<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UFO Race - Space Racing</title>
    <!-- Supabase Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a2e 0%, #1a1a4e 50%, #0a0a2e 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        #gameContainer {
            background: linear-gradient(135deg, #1a1a3e 0%, #2a2a5e 100%);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(102, 126, 234, 0.3), 0 0 30px rgba(102, 126, 234, 0.2);
            text-align: center;
            border: 2px solid rgba(102, 126, 234, 0.3);
        }

        h1 {
            color: #8af3ff;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(138, 243, 255, 0.5), 0 0 20px rgba(138, 243, 255, 0.3);
            animation: titleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from {
                text-shadow: 0 0 10px rgba(138, 243, 255, 0.5), 0 0 20px rgba(138, 243, 255, 0.3);
            }

            to {
                text-shadow: 0 0 20px rgba(138, 243, 255, 0.8), 0 0 30px rgba(138, 243, 255, 0.5), 0 0 40px rgba(138, 243, 255, 0.3);
            }
        }

        #canvas {
            border: 4px solid rgba(138, 243, 255, 0.5);
            border-radius: 10px;
            background: #0a0a1a;
            display: block;
            margin: 20px auto;
            box-shadow: 0 0 20px rgba(138, 243, 255, 0.3), inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .controls {
            margin: 20px 0;
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .player-info {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.3) 0%, rgba(118, 75, 162, 0.3) 100%);
            color: #8af3ff;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: bold;
            min-width: 200px;
            border: 2px solid rgba(138, 243, 255, 0.3);
            box-shadow: 0 0 15px rgba(138, 243, 255, 0.2);
        }

        .player1 {
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.3) 0%, rgba(245, 87, 108, 0.3) 100%);
            border-color: rgba(240, 147, 251, 0.5);
            box-shadow: 0 0 15px rgba(240, 147, 251, 0.3);
        }

        .player2 {
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.3) 0%, rgba(0, 242, 254, 0.3) 100%);
            border-color: rgba(79, 172, 254, 0.5);
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.3);
        }

        button {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.5) 0%, rgba(118, 75, 162, 0.5) 100%);
            color: #8af3ff;
            border: 2px solid rgba(138, 243, 255, 0.3);
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            margin: 5px;
            box-shadow: 0 0 15px rgba(138, 243, 255, 0.2);
            text-shadow: 0 0 5px rgba(138, 243, 255, 0.5);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 25px rgba(138, 243, 255, 0.4), 0 10px 20px rgba(0, 0, 0, 0.3);
            border-color: rgba(138, 243, 255, 0.6);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.7) 0%, rgba(118, 75, 162, 0.7) 100%);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .mute-btn {
            background: linear-gradient(135deg, rgba(138, 243, 255, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
            border: 2px solid rgba(138, 243, 255, 0.4);
            padding: 12px 30px;
            font-size: 1.1em;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
        }

        .mute-btn:hover {
            background: linear-gradient(135deg, rgba(138, 243, 255, 0.3) 0%, rgba(118, 75, 162, 0.3) 100%);
            border-color: rgba(138, 243, 255, 0.6);
        }

        .mute-btn.muted {
            background: linear-gradient(135deg, rgba(245, 87, 108, 0.2) 0%, rgba(240, 147, 251, 0.2) 100%);
            border-color: rgba(245, 87, 108, 0.4);
        }

        .mute-btn.muted:hover {
            background: linear-gradient(135deg, rgba(245, 87, 108, 0.3) 0%, rgba(240, 147, 251, 0.3) 100%);
            border-color: rgba(245, 87, 108, 0.6);
        }

        .mute-icon {
            font-size: 1.3em;
        }

        #gameOver,
        #startScreen,
        #shopScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a3e 0%, #2a2a5e 100%);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(102, 126, 234, 0.5), 0 0 40px rgba(138, 243, 255, 0.3);
            border: 2px solid rgba(138, 243, 255, 0.3);
            display: none;
            z-index: 1000;
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
        }

        #gameOver h2,
        #shopScreen h2 {
            color: #8af3ff;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(138, 243, 255, 0.5), 0 0 20px rgba(138, 243, 255, 0.3);
        }

        #gameOver p {
            font-size: 1.5em;
            margin: 10px 0;
            color: #8af3ff;
        }

        #startScreen {
            display: block;
        }

        #startScreen h2 {
            color: #8af3ff;
            font-size: 3em;
            margin-bottom: 30px;
            text-shadow: 0 0 15px rgba(138, 243, 255, 0.7), 0 0 30px rgba(138, 243, 255, 0.4);
            animation: titleGlow 2s ease-in-out infinite alternate;
        }

        #startScreen .start-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            font-size: 2em;
            padding: 20px 60px;
            margin: 20px 0;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .coin-display {
            font-size: 2em;
            color: #ffd700;
            margin: 20px 0;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .shop-btn {
            background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%);
            color: #333;
        }

        .leaderboard-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: #fff;
            font-size: 1.2em;
        }

        #leaderboardScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a3e 0%, #2a2a5e 100%);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(102, 126, 234, 0.5), 0 0 40px rgba(138, 243, 255, 0.3);
            border: 2px solid rgba(138, 243, 255, 0.3);
            z-index: 1000;
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
            min-width: 600px;
        }

        #leaderboardScreen h2 {
            color: #8af3ff;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(138, 243, 255, 0.5), 0 0 20px rgba(138, 243, 255, 0.3);
        }

        .leaderboard-container {
            margin: 20px 0;
        }

        .leaderboard-header {
            display: grid;
            grid-template-columns: 80px 1fr 120px 100px;
            gap: 10px;
            padding: 15px;
            background: rgba(138, 243, 255, 0.1);
            border-radius: 10px;
            font-weight: bold;
            color: #8af3ff;
            margin-bottom: 10px;
        }

        .leaderboard-entries {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .leaderboard-entry {
            display: grid;
            grid-template-columns: 80px 1fr 120px 100px;
            gap: 10px;
            padding: 12px 15px;
            background: rgba(26, 26, 62, 0.5);
            border: 2px solid rgba(138, 243, 255, 0.2);
            border-radius: 8px;
            color: #8af3ff;
            transition: all 0.3s;
        }

        .leaderboard-entry:hover {
            background: rgba(138, 243, 255, 0.1);
            border-color: rgba(138, 243, 255, 0.4);
        }

        .leaderboard-entry.top3 {
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.4);
        }

        .rank-col {
            font-weight: bold;
            font-size: 1.2em;
        }

        .rank-col.gold {
            color: #ffd700;
        }

        .rank-col.silver {
            color: #c0c0c0;
        }

        .rank-col.bronze {
            color: #cd7f32;
        }

        .name-col {
            text-align: left;
            font-weight: bold;
        }

        .score-col {
            color: #92fe9d;
            font-weight: bold;
        }

        .mode-col {
            font-size: 0.9em;
        }

        .mode-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.85em;
        }

        .mode-badge.solo {
            background: rgba(240, 147, 251, 0.3);
            color: #f093fb;
        }

        .mode-badge.multiplayer {
            background: rgba(79, 175, 254, 0.3);
            color: #4faffe;
        }

        #nameEntryModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .name-entry-content {
            background: linear-gradient(135deg, #1a1a3e 0%, #2a2a5e 100%);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid rgba(138, 243, 255, 0.5);
            box-shadow: 0 20px 60px rgba(102, 126, 234, 0.5);
            text-align: center;
            animation: modalFadeIn 0.3s ease-out;
        }

        .name-entry-content h3 {
            color: #ffd700;
            font-size: 2em;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .skins-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
            max-width: 800px;
        }

        .skin-card {
            background: rgba(26, 26, 62, 0.5);
            padding: 20px;
            border-radius: 15px;
            border: 3px solid rgba(138, 243, 255, 0.2);
            transition: all 0.3s;
        }

        .skin-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(138, 243, 255, 0.3);
            border-color: rgba(138, 243, 255, 0.5);
        }

        .skin-card.owned {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }

        .skin-card.selected {
            border-color: #8af3ff;
            background: rgba(138, 243, 255, 0.1);
            box-shadow: 0 0 20px rgba(138, 243, 255, 0.4);
        }

        .skin-preview {
            width: 100px;
            height: 100px;
            margin: 10px auto;
            border-radius: 10px;
            border: 2px solid rgba(138, 243, 255, 0.3);
            box-shadow: 0 0 10px rgba(138, 243, 255, 0.2);
        }

        .skin-name {
            font-weight: bold;
            font-size: 1.1em;
            margin: 10px 0;
            color: #8af3ff;
            text-shadow: 0 0 5px rgba(138, 243, 255, 0.3);
        }

        .skin-price {
            color: #ffd700;
            font-size: 1.3em;
            font-weight: bold;
        }

        .player-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .player-tab {
            padding: 10px 30px;
            background: rgba(26, 26, 62, 0.5);
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            color: #8af3ff;
            border: 2px solid rgba(138, 243, 255, 0.2);
            transition: all 0.3s ease;
        }

        .player-tab.active {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.7) 0%, rgba(118, 75, 162, 0.7) 100%);
            color: #8af3ff;
            border-color: rgba(138, 243, 255, 0.5);
            box-shadow: 0 0 15px rgba(138, 243, 255, 0.3);
        }

        .buy-btn {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: white;
            padding: 10px 20px;
            font-size: 1em;
        }

        .select-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 10px 20px;
            font-size: 1em;
        }

        .earned-coins {
            color: #ffd700;
            font-size: 1.8em;
            font-weight: bold;
            margin: 15px 0;
        }

        .controls-preview {
            background: rgba(26, 26, 62, 0.5);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: left;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
            border: 2px solid rgba(138, 243, 255, 0.2);
            box-shadow: 0 0 10px rgba(138, 243, 255, 0.1);
        }

        .controls-preview h3 {
            color: #8af3ff;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 5px rgba(138, 243, 255, 0.5);
        }

        .controls-preview p {
            margin: 8px 0;
            font-size: 1.1em;
            color: #8af3ff;
        }

        #confirmModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }

        .confirm-content {
            background: linear-gradient(135deg, #1a1a3e 0%, #2a2a5e 100%);
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(102, 126, 234, 0.5),
                0 0 40px rgba(138, 243, 255, 0.3);
            border: 2px solid rgba(138, 243, 255, 0.3);
            text-align: center;
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .confirm-content h3 {
            color: #8af3ff;
            font-size: 1.8em;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(138, 243, 255, 0.5);
        }

        .confirm-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .confirm-btn {
            padding: 15px 40px;
            font-size: 1.3em;
            font-weight: bold;
            border-radius: 10px;
            border: 2px solid;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .yes-btn {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: white;
            border-color: rgba(0, 255, 136, 0.5);
        }

        .yes-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            border-color: rgba(0, 255, 136, 0.8);
        }

        .no-btn {
            background: linear-gradient(135deg, #ff4d94 0%, #ff0066 100%);
            color: white;
            border-color: rgba(255, 77, 148, 0.5);
        }

        .no-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(255, 77, 148, 0.5);
            border-color: rgba(255, 77, 148, 0.8);
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            #gameContainer {
                padding: 10px;
            }

            h1 {
                font-size: 1.5em;
            }

            .controls {
                flex-direction: column;
                gap: 10px;
            }

            .player-info {
                min-width: 150px;
                font-size: 1em;
                padding: 10px;
            }

            button {
                padding: 12px 20px;
                font-size: 1em;
            }

            .controls-preview {
                display: none;
            }

            #startScreen {
                padding: 20px;
                max-width: 95vw;
            }

            #startScreen h2 {
                font-size: 2em;
            }

            .coin-display {
                font-size: 1.5em;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.2em;
            }

            .player-info {
                min-width: 120px;
            }

            button {
                padding: 10px 15px;
                font-size: 0.9em;
            }

            #startScreen h2 {
                font-size: 1.5em;
            }
        }


        /* Mode selection buttons */
        .mode-btn {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.5) 0%, rgba(118, 75, 162, 0.5) 100%);
            color: #8af3ff;
            border: 2px solid rgba(138, 243, 255, 0.3);
            padding: 20px 50px;
            font-size: 1.5em;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            margin: 10px;
            display: inline-block;
            min-width: 280px;
            box-shadow: 0 0 15px rgba(138, 243, 255, 0.2);
            text-shadow: 0 0 5px rgba(138, 243, 255, 0.5);
        }

        .mode-btn span {
            display: block;
            font-size: 0.5em;
            margin-top: 5px;
            opacity: 0.8;
        }

        .mode-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 30px rgba(138, 243, 255, 0.5);
            border-color: rgba(138, 243, 255, 0.7);
        }

        .mode-btn.selected {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-color: rgba(240, 147, 251, 0.8);
            box-shadow: 0 0 25px rgba(240, 147, 251, 0.4);
        }

        .desktop-mode-btn:hover {
            background: linear-gradient(135deg, rgba(0, 201, 255, 0.6) 0%, rgba(146, 254, 157, 0.6) 100%);
        }

        .mobile-mode-btn:hover {
            background: linear-gradient(135deg, rgba(0, 201, 255, 0.6) 0%, rgba(146, 254, 157, 0.6) 100%);
        }

        /* Exit button for mobile */
        #mobileExitBtn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1001;
            padding: 10px 15px;
            font-size: 14px;
            background: rgba(255, 77, 148, 0.8);
            border: 2px solid rgba(255, 77, 148, 0.9);
            border-radius: 8px;
            color: white;
            display: none;
        }

        /* Fullscreen canvas adjustments */
        :fullscreen #gameContainer {
            padding: 5px;
            border-radius: 0;
            box-shadow: none;
            border: none;
            background: #0a0a1a;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        :fullscreen #canvas {
            max-width: 100vw;
            max-height: calc(100vh - 100px);
        }

        :fullscreen .controls {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Virtual Joystick Styling */
        #virtualJoystick {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 1000;
            display: none;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .joystick-base {
            position: relative;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: radial-gradient(circle at center, rgba(138, 243, 255, 0.08) 0%, rgba(138, 243, 255, 0.03) 100%);
            border: 2px solid rgba(138, 243, 255, 0.15);
            box-shadow: 0 0 20px rgba(138, 243, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(138, 243, 255, 0.25), rgba(138, 243, 255, 0.12));
            border: 2px solid rgba(138, 243, 255, 0.25);
            box-shadow: 0 0 15px rgba(138, 243, 255, 0.1);
            transition: all 0.1s ease-out;
            will-change: transform;
        }

        .joystick-base.active {
            background: radial-gradient(circle at center, rgba(138, 243, 255, 0.15) 0%, rgba(138, 243, 255, 0.05) 100%);
            border-color: rgba(138, 243, 255, 0.25);
            box-shadow: 0 0 30px rgba(138, 243, 255, 0.1);
        }

        .joystick-knob.active {
            background: radial-gradient(circle at 30% 30%, rgba(138, 243, 255, 0.4), rgba(138, 243, 255, 0.2));
            border-color: rgba(138, 243, 255, 0.4);
        }

        /* Mobile Score Overlay */
        .mobile-score-overlay {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 999;
            pointer-events: none;
            display: none;
        }

        :fullscreen.mobile-fullscreen-mode .mobile-score-overlay {
            display: block;
        }

        .overlay-player-info {
            background: linear-gradient(135deg, rgba(26, 26, 62, 0.85) 0%, rgba(42, 42, 94, 0.85) 100%);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(138, 243, 255, 0.25);
            border-radius: 12px;
            padding: 10px 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 100px;
        }

        .overlay-lives {
            font-size: 1.2em;
            text-align: center;
            color: #ff4d94;
            text-shadow: 0 0 5px rgba(255, 77, 148, 0.5);
        }

        .overlay-score {
            font-size: 1.5em;
            font-weight: bold;
            color: #8af3ff;
            text-align: center;
            text-shadow: 0 0 8px rgba(138, 243, 255, 0.6);
        }

        .overlay-score::before {
            content: '‚≠ê ';
            font-size: 0.8em;
        }

        /* Mobile fullscreen - true 100% screen */
        :fullscreen.mobile-fullscreen-mode #canvas {
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
            border: none;
            border-radius: 0;
        }

        :fullscreen.mobile-fullscreen-mode #gameContainer {
            padding: 0;
            border: none;
            width: 100vw;
            height: 100vh;
        }

        :fullscreen.mobile-fullscreen-mode .controls {
            display: none;
        }

        :fullscreen.mobile-fullscreen-mode h1 {
            display: none;
        }

        :fullscreen.mobile-fullscreen-mode #virtualJoystick {
            bottom: 20px;
            left: 20px;
        }

        /* Responsive joystick for smaller screens */
        @media (max-width: 640px) {
            #virtualJoystick {
                bottom: 15px;
                left: 15px;
            }

            .joystick-base {
                width: 100px;
                height: 100px;
            }

            .joystick-knob {
                width: 42px;
                height: 42px;
            }
        }
    </style>
</head>

<body>
    <div id="startScreen">
        <h2>üõ∏ UFO RACE üõ∏</h2>
        <div class="coin-display">üí∞ Coins: <span id="totalCoins">0</span></div>

        <div id="modeSelection" style="margin: 30px 0;">
            <h3
                style="color: #8af3ff; margin-bottom: 15px; font-size: 1.5em; text-shadow: 0 0 5px rgba(138, 243, 255, 0.5);">
                Select Control Mode:</h3>
            <button class="mode-btn desktop-mode-btn" onclick="selectDesktopMode()">
                üñ•Ô∏è DESKTOP MODE
                <span>Keyboard Controls</span>
            </button>
            <button class="mode-btn mobile-mode-btn" onclick="selectMobileMode()">
                üì± MOBILE MODE
                <span>Touch Joystick</span>
            </button>
        </div>

        <div id="gameOptions" style="display: none;">
            <div style="margin: 20px 0;">
                <label
                    style="font-size: 1.3em; font-weight: bold; color: #8af3ff; text-shadow: 0 0 5px rgba(138, 243, 255, 0.5);">Game
                    Mode:</label>
                <select id="gameModeSelect"
                    style="font-size: 1.2em; padding: 10px; border-radius: 5px; margin-left: 10px; background: rgba(26, 26, 62, 0.7); color: #8af3ff; border: 2px solid rgba(138, 243, 255, 0.3);">
                    <option value="solo">Solo Run</option>
                    <option value="boss">Boss Rush (NEW!)</option>
                    <option value="multiplayer" selected>2 Players</option>
                </select>
            </div>

            <div style="margin: 20px 0;">
                <label
                    style="font-size: 1.3em; font-weight: bold; color: #8af3ff; text-shadow: 0 0 5px rgba(138, 243, 255, 0.5);">Difficulty:</label>
                <select id="difficultySelect"
                    style="font-size: 1.2em; padding: 10px; border-radius: 5px; margin-left: 10px; background: rgba(26, 26, 62, 0.7); color: #8af3ff; border: 2px solid rgba(138, 243, 255, 0.3);">
                    <option value="easy">Easy</option>
                    <option value="normal" selected>Normal</option>
                    <option value="hard">Hard</option>
                    <option value="very-difficult">Very Hard</option>
                </select>
            </div>

            <div style="margin: 20px 0;">
                <button type="button" id="muteToggle" class="mute-btn">
                    <span class="mute-icon">üîä</span>
                    <span class="mute-text">Music</span>
                </button>
            </div>

            <button id="startGameBtn" class="start-btn" onclick="initiateGame()">START GAME!</button>
            <button class="shop-btn" onclick="openShop()">üõí SHOP</button>
            <button class="leaderboard-btn" onclick="openLeaderboard()">üèÜ HIGH SCORES</button>
            <button id="desktopFullscreenBtn" style="display: none;" onclick="toggleFullscreen()"
                style="background: linear-gradient(135deg, rgba(0, 201, 255, 0.5) 0%, rgba(146, 254, 157, 0.5) 100%); border-color: rgba(0, 201, 255, 0.5);">üñ•Ô∏è
                FULLSCREEN</button>
            <div class="controls-preview" id="controlsPreview">
                <h3>How to Play (2 Players):</h3>
                <p><strong>üéÆ Player 1 (Pink):</strong> W A S D</p>
                <p><strong>üéÆ Player 2 (Blue):</strong> Arrows ‚Üë ‚Üê ‚Üì ‚Üí</p>
                <p>üõ∏ UFOs move in the direction of the last key pressed!</p>
                <p>üíé Collect energy crystals to gain points</p>
                <p>‚ö†Ô∏è Watch out for asteroids and don't fall off screen!</p>
                <p>üèÜ The pilot with more points wins!</p>
                <p>üí∞ Both players' points convert to coins!</p>
                <p><strong>‚¨ÖÔ∏è Exit:</strong> Press Q to return to menu</p>
            </div>
        </div>
    </div>

    <div id="shopScreen">
        <h2>üõí SHOP</h2>
        <div class="coin-display">üí∞ Coins: <span id="shopCoins">0</span></div>

        <div class="player-selector" style="margin-bottom: 10px;">
            <div class="player-tab player-select active" onclick="selectPlayerTab(1)">üë§ Player 1</div>
            <div class="player-tab player-select" onclick="selectPlayerTab(2)">üë§ Player 2</div>
        </div>

        <div class="player-selector">
            <div class="player-tab shop-tab active" onclick="selectShopTab('skins')">üõ∏ UFO</div>
            <div class="player-tab shop-tab" onclick="selectShopTab('themes')">üåå Backgrounds</div>
        </div>

        <div id="skinsContainer" class="skins-grid"></div>
        <div id="themesContainer" class="skins-grid" style="display:none;"></div>

        <button onclick="closeShop()">Back to Menu</button>
    </div>

    <div id="leaderboardScreen" style="display:none;">
        <h2>üèÜ HIGH SCORES</h2>
        <div class="leaderboard-container">
            <div class="leaderboard-header">
                <div class="rank-col">Rank</div>
                <div class="name-col">Player</div>
                <div class="score-col">Points</div>
                <div class="mode-col">Mode</div>
            </div>
            <div id="leaderboardEntries" class="leaderboard-entries">
                <!-- Leaderboard entries will be inserted here -->
            </div>
        </div>
        <button onclick="closeLeaderboard()">Back to Menu</button>
    </div>

    <div id="gameContainer" style="display:none;">
        <h1>üõ∏ UFO Race üõ∏</h1>

        <div class="controls">
            <div class="player-info player1" id="player1Info">
                <div>Player 1 <span id="lives1">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
                <div>Points: <span id="score1">0</span></div>
            </div>
            <div class="player-info player2" id="player2Info">
                <div>Player 2 <span id="lives2">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
                <div>Points: <span id="score2">0</span></div>
            </div>
        </div>

        <canvas id="canvas" width="1200" height="600"></canvas>

        <button type="button" onclick="exitToMenu()" style="margin-top: 20px;">‚¨ÖÔ∏è Exit to Menu (Q)</button>
    </div>

    <!-- Virtual Joystick for Mobile -->
    <div id="virtualJoystick">
        <div id="joystickBase" class="joystick-base">
            <div id="joystickKnob" class="joystick-knob"></div>
        </div>
    </div>

    <!-- Mobile Score Overlay -->
    <div id="mobileScoreOverlay" class="mobile-score-overlay">
        <div class="overlay-player-info">
            <div class="overlay-lives">
                <span id="overlayLives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
            </div>
            <div class="overlay-score">
                <span id="overlayScore">0</span>
            </div>
        </div>
    </div>

    <!-- Mobile Exit Button -->
    <button id="mobileExitBtn" type="button" onclick="exitMobileGame()">‚úï EXIT</button>

    <div id="gameOver">
        <h2>Game Over!</h2>
        <p id="winnerText"></p>
        <p>Player 1: <span id="finalScore1">0</span> points</p>
        <p>Player 2: <span id="finalScore2">0</span> points</p>
        <p class="earned-coins">üí∞ Coins Earned: +<span id="earnedCoins">0</span></p>
        <button onclick="backToMenu()">Main Menu</button>
        <button onclick="restartGame()">Play Again</button>
    </div>

    <div id="confirmModal">
        <div class="confirm-content">
            <h3 id="confirmMessage">Are you sure?</h3>
            <div class="confirm-buttons">
                <button id="confirmYes" class="confirm-btn yes-btn">YES</button>
                <button id="confirmNo" class="confirm-btn no-btn">NO</button>
            </div>
        </div>
    </div>

    <div id="nameEntryModal" style="display: none;">
        <div class="name-entry-content">
            <h3>üèÜ New Record!</h3>
            <p style="margin: 15px 0; color: #8af3ff;">Your score: <span id="newHighScore">0</span> points</p>
            <p style="margin-bottom: 15px; color: #92fe9d;">Enter your name:</p>
            <input type="text" id="playerNameInput" maxlength="20" placeholder="Enter name..." style="padding: 10px; font-size: 1.2em; width: 250px; text-align: center;
                          border: 2px solid #8af3ff; border-radius: 5px; background: #1a1a3e;
                          color: #8af3ff;">
            <div style="margin-top: 20px;">
                <button onclick="saveHighScore()" class="confirm-btn yes-btn">Save</button>
                <button onclick="skipHighScore()" class="confirm-btn no-btn">Skip</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== SUPABASE CONFIGURATION ====================
        const SUPABASE_URL = 'https://hfybfoovezpcugfsnafy.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhmeWJmb292ZXpwY3VnZnNuYWZ5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4NDcwMzYsImV4cCI6MjA4MDQyMzAzNn0.ZKYGa9w40qUxa32tj_L6G5_Ne-MQ_tOf--B3AQfq8VM';

        // Initialize Supabase client
        let supabase = null;
        let supabaseAvailable = false;

        try {
            const { createClient } = window.supabase;
            supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            supabaseAvailable = true;
            console.log('‚úÖ Supabase initialized successfully');
        } catch (error) {
            console.error('‚ùå Failed to initialize Supabase:', error);
            supabaseAvailable = false;
        }
        // ================================================================

        // ==================== MOBILE DETECTION & SETUP ====================
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        let isMobileFullscreen = false;

        // Control mode state
        let controlMode = null; // 'desktop' or 'mobile'
        let modeSelected = false;

        // Virtual joystick state
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickMaxDistance = 35;
        let joystickThreshold = 8;
        let currentJoystickDirection = { x: 0, y: 0 };

        // Mode selection functions
        function selectDesktopMode() {
            controlMode = 'desktop';
            modeSelected = true;

            // Update UI
            document.querySelector('.desktop-mode-btn').classList.add('selected');
            document.querySelector('.mobile-mode-btn').classList.remove('selected');
            document.getElementById('gameOptions').style.display = 'block';

            // Show desktop-specific options
            document.getElementById('gameModeSelect').parentElement.style.display = 'block';
            document.getElementById('controlsPreview').style.display = 'block';
            document.getElementById('desktopFullscreenBtn').style.display = 'inline-block';
        }

        function selectMobileMode() {
            controlMode = 'mobile';
            modeSelected = true;

            // Update UI
            document.querySelector('.mobile-mode-btn').classList.add('selected');
            document.querySelector('.desktop-mode-btn').classList.remove('selected');
            document.getElementById('gameOptions').style.display = 'block';

            // Force solo mode for mobile
            document.getElementById('gameModeSelect').value = 'solo';
            document.getElementById('gameModeSelect').parentElement.style.display = 'none';
            document.getElementById('controlsPreview').style.display = 'none';
            document.getElementById('desktopFullscreenBtn').style.display = 'none';
        }

        function initiateGame() {
            if (!modeSelected) {
                alert('Please select a control mode first!');
                return;
            }

            if (controlMode === 'mobile') {
                startMobileGameEnhanced();
            } else {
                startGame();
            }
        }

        // Virtual joystick setup
        function setupVirtualJoystick() {
            const joystickBase = document.getElementById('joystickBase');
            const joystickKnob = document.getElementById('joystickKnob');

            if (!joystickBase || !joystickKnob) return;

            // Get joystick center position
            function getJoystickCenter() {
                const rect = joystickBase.getBoundingClientRect();
                return {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
            }

            // Update joystick direction from touch position
            function updateJoystickDirection(touchX, touchY) {
                const deltaX = touchX - joystickCenter.x;
                const deltaY = touchY - joystickCenter.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // Update visual position (clamped to max distance)
                const clampedDistance = Math.min(distance, joystickMaxDistance);
                const angle = Math.atan2(deltaY, deltaX);
                const knobX = Math.cos(angle) * clampedDistance;
                const knobY = Math.sin(angle) * clampedDistance;

                joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;

                // Only update direction if past threshold
                if (distance > joystickThreshold) {
                    // Normalize to unit vector
                    const normalizedX = deltaX / distance;
                    const normalizedY = deltaY / distance;

                    // Convert to 4-directional input (dominant axis)
                    if (Math.abs(normalizedX) > Math.abs(normalizedY)) {
                        // Horizontal dominant
                        currentJoystickDirection = {
                            x: normalizedX > 0 ? 1 : -1,
                            y: 0
                        };
                    } else {
                        // Vertical dominant
                        currentJoystickDirection = {
                            x: 0,
                            y: normalizedY > 0 ? 1 : -1
                        };
                    }

                    // Update snake direction if game is running
                    if (gameRunning && typeof snake1 !== 'undefined') {
                        snake1.nextDirection = currentJoystickDirection;
                    }
                }
            }

            // Reset joystick to center
            function resetJoystick() {
                joystickKnob.style.transform = 'translate(0, 0)';
                joystickBase.classList.remove('active');
                joystickKnob.classList.remove('active');
                currentJoystickDirection = { x: 0, y: 0 };
                joystickActive = false;
            }

            // Touch start
            joystickBase.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                joystickCenter = getJoystickCenter();
                joystickBase.classList.add('active');
                joystickKnob.classList.add('active');

                const touch = e.touches[0];
                updateJoystickDirection(touch.clientX, touch.clientY);
            }, { passive: false });

            // Touch move
            joystickBase.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!joystickActive) return;

                const touch = e.touches[0];
                updateJoystickDirection(touch.clientX, touch.clientY);
            }, { passive: false });

            // Touch end
            joystickBase.addEventListener('touchend', (e) => {
                e.preventDefault();
                resetJoystick();
            }, { passive: false });

            // Touch cancel
            joystickBase.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                resetJoystick();
            }, { passive: false });
        }

        // Start mobile game with enhanced fullscreen and joystick
        async function startMobileGameEnhanced() {
            try {
                // Add mobile fullscreen class to enable CSS
                document.documentElement.classList.add('mobile-fullscreen-mode');

                // Set to solo mode for mobile
                document.getElementById('gameModeSelect').value = 'solo';

                // Request fullscreen
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    await elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    await elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    await elem.msRequestFullscreen();
                }

                // Lock to landscape orientation
                if (screen.orientation && screen.orientation.lock) {
                    try {
                        await screen.orientation.lock('landscape');
                    } catch (err) {
                        console.log('Orientation lock not supported:', err);
                    }
                }

                isMobileFullscreen = true;

                // Show virtual joystick and mobile exit button
                document.getElementById('virtualJoystick').style.display = 'block';
                document.getElementById('mobileExitBtn').style.display = 'block';

                // Setup virtual joystick
                setupVirtualJoystick();

                // Start the game
                startGame();

            } catch (err) {
                console.log('Fullscreen error:', err);
                // Fallback: start game without fullscreen but with mobile class
                document.documentElement.classList.add('mobile-fullscreen-mode');
                document.getElementById('gameModeSelect').value = 'solo';
                document.getElementById('virtualJoystick').style.display = 'block';
                setupVirtualJoystick();
                startGame();
            }
        }

        // Exit mobile fullscreen game
        function exitMobileGame() {
            // Remove mobile fullscreen class
            document.documentElement.classList.remove('mobile-fullscreen-mode');

            // Hide virtual joystick and overlay
            document.getElementById('virtualJoystick').style.display = 'none';
            document.getElementById('mobileExitBtn').style.display = 'none';

            // Exit fullscreen
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }

            // Unlock orientation
            if (screen.orientation && screen.orientation.unlock) {
                screen.orientation.unlock();
            }

            isMobileFullscreen = false;

            // Exit to menu
            exitToMenu();
        }

        // Handle fullscreen change events
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);

        function handleFullscreenChange() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                // Exited fullscreen
                if (isMobileFullscreen) {
                    document.documentElement.classList.remove('mobile-fullscreen-mode');
                    document.getElementById('virtualJoystick').style.display = 'none';
                    document.getElementById('mobileExitBtn').style.display = 'none';
                    if (screen.orientation && screen.orientation.unlock) {
                        screen.orientation.unlock();
                    }
                    isMobileFullscreen = false;
                }
            }
        }

        // Prevent default touch behaviors during gameplay
        document.addEventListener('touchmove', (e) => {
            if (gameRunning && isMobileFullscreen) {
                e.preventDefault();
            }
        }, { passive: false });
        // ================================================================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // High DPI support
        const dpr = window.devicePixelRatio || 1;
        const canvasWidth = 1200;
        const canvasHeight = 600;

        // Set actual canvas size (device pixels)
        canvas.width = canvasWidth * dpr;
        canvas.height = canvasHeight * dpr;

        // Scale context to match device pixel ratio
        ctx.scale(dpr, dpr);

        // Responsive canvas sizing for mobile
        function resizeCanvasDisplay() {
            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
            const isMobileMode = document.documentElement.classList.contains('mobile-fullscreen-mode');

            if (isFullscreen && isMobileMode) {
                // Mobile fullscreen: true 100vw x 100vh
                canvas.style.width = '100vw';
                canvas.style.height = '100vh';
                canvas.style.maxWidth = '100vw';
                canvas.style.maxHeight = '100vh';
            } else {
                // Desktop fullscreen or normal mode: maintain aspect ratio with padding
                const padding = isFullscreen ? 20 : 40;
                const maxWidth = window.innerWidth - padding;
                const maxHeight = window.innerHeight - (isFullscreen ? 120 : 200);
                const aspectRatio = canvasWidth / canvasHeight; // 2:1

                let displayWidth = maxWidth;
                let displayHeight = displayWidth / aspectRatio;

                if (displayHeight > maxHeight) {
                    displayHeight = maxHeight;
                    displayWidth = displayHeight * aspectRatio;
                }

                // Apply constraints
                displayWidth = Math.min(displayWidth, canvasWidth);
                displayHeight = Math.min(displayHeight, canvasHeight);

                canvas.style.width = displayWidth + 'px';
                canvas.style.height = displayHeight + 'px';
            }
        }

        // Initial sizing
        resizeCanvasDisplay();

        // Resize on window changes
        window.addEventListener('resize', resizeCanvasDisplay);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvasDisplay, 100);
        });

        const GRID_SIZE = 20;
        const COLS = Math.floor(canvasWidth / GRID_SIZE);
        const ROWS = Math.floor(canvasHeight / GRID_SIZE);

        let gameRunning = false;
        let cameraOffset = 0;
        let maxProgressX = 0; // Maximum X position ever achieved
        let maxSpeedAchieved = 1.0; // Maximum speed any snake achieved
        let scrollSpeed = 0.8;
        let lastUpdateTime1 = 0;
        let lastUpdateTime2 = 0;
        let lastFrameTime = 0;
        let baseSnakeUpdateInterval = 120;
        let currentShopPlayer = 1;
        let confirmCallback = null;
        let gamePaused = false;
        let resumeCountdown = 0;
        let resumeCountdownStart = 0;

        // Game mode and lives system
        let gameMode = 'multiplayer'; // 'multiplayer' or 'solo'
        let gameStartTime = 0;
        let cameraStarted = false;
        const CAMERA_DELAY = 3000; // 3 seconds delay

        // Difficulty settings
        let currentDifficulty = 'normal';
        // Difficulty settings
        // let currentDifficulty = 'normal'; <-- REMOVED DUPLICATE
        // let distanceTraveled = 0; <-- REMOVED DUPLICATE

        // BOSS & ROCKET VARIABLES
        let boss = null; // Will be an object when active
        let playerAmmo = 5;
        let maxAmmo = 5;
        let lastRocketReload = 0;
        let rockets = []; // Array of active rockets
        let mouseX = 0;
        let mouseY = 0;
        let bossActive = false;
        let distToBoss = 2000; // Trigger boss after this distance (or test value)

        class Rocket {
            constructor(x, y, targetX, targetY) {
                this.x = x;
                this.y = y;
                this.speed = 15;
                this.size = 8;
                this.active = true;

                // Calculate direction towards mouse
                const angle = Math.atan2(targetY - y, targetX - x);
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;

                // Trail system
                this.trailTimer = 0;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Deactivate if off screen
                if (this.x > canvasWidth + 100 || this.x < -100 || this.y > canvasHeight + 100 || this.y < -100) {
                    this.active = false;
                }

                // Add particles
                this.trailTimer++;
                if (this.trailTimer % 2 === 0) {
                    particleSystem.emit(this.x, this.y, -this.vx * 0.2, -this.vy * 0.2, 15, 3, '#ffaa00', 'circle');
                }
            }

            draw(ctx, cameraOffset) {
                const screenX = this.x - cameraOffset;
                ctx.fillStyle = '#ff3300';
                ctx.beginPath();
                ctx.arc(screenX, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // Glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff3300';
                ctx.beginPath();
                ctx.arc(screenX, this.y, this.size + 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Boss {
            constructor() {
                this.width = 200;
                this.height = 100;
                this.x = canvasWidth + 200;
                this.y = canvasHeight / 2;
                this.hp = 100;
                this.maxHp = 100;
                this.state = 'entering';
                this.enterTargetX = 0;
                this.moveTimer = 0;
                this.offsetY = 0;

                // Snake Boss specific properties
                this.segments = [];
                const segmentCount = 12;
                for (let i = 0; i < segmentCount; i++) {
                    this.segments.push({
                        x: this.x + i * 40,
                        y: this.y,
                        offset: i * 0.5
                    });
                }
            }

            spawn(cameraX) {
                this.x = cameraX + canvasWidth + 200;
                this.enterTargetX = cameraX + canvasWidth - 300;
                this.state = 'entering';
                this.hp = 100;
                bossActive = true;

                // Re-init segments
                for (let i = 0; i < this.segments.length; i++) {
                    this.segments[i].x = this.x + i * 40;
                    this.segments[i].y = this.y;
                }

                // Notification
                const msg = document.createElement('div');
                msg.textContent = "WARNING: SPACE SERPENT!";
                msg.style.position = "fixed";
                msg.style.top = "20%";
                msg.style.left = "50%";
                msg.style.transform = "translate(-50%, -50%)";
                msg.style.color = "#00ff00";
                msg.style.fontFamily = "Courier New, monospace";
                msg.style.fontSize = "50px";
                msg.style.fontWeight = "bold";
                msg.style.textShadow = "0 0 20px #00ff00";
                msg.style.zIndex = "2000";
                msg.id = "bossWarning";
                document.body.appendChild(msg);

                setTimeout(() => {
                    const el = document.getElementById('bossWarning');
                    if (el) el.remove();
                }, 3000);
            }

            update(cameraX) {
                this.moveTimer += 0.05;

                if (this.state === 'entering') {
                    if (this.x > this.enterTargetX) {
                        this.x -= 4;
                    } else {
                        this.state = 'idle';
                    }
                } else if (this.state === 'idle') {
                    // Head movement (Sine wave up/down)
                    this.y = (canvasHeight / 2) + Math.sin(this.moveTimer) * 120;
                    this.x = cameraX + canvasWidth - 300 + Math.cos(this.moveTimer * 0.7) * 50;
                }

                // Update segments to follow head (Sine wave body)
                for (let i = 0; i < this.segments.length; i++) {
                    const seg = this.segments[i];
                    // Wave motion for body
                    const wave = Math.sin(this.moveTimer - i * 0.5) * 60;

                    const screenHeadX = this.x;
                    const targetX = screenHeadX + (i + 1) * 35;
                    const targetY = this.y + wave;

                    seg.x = targetX;
                    seg.y = targetY;
                }
            }

            draw(ctx, cameraOffset) {
                const screenX = this.x - cameraOffset;

                // Draw HP Bar
                const barWidth = 150;
                const barHeight = 15;
                ctx.fillStyle = '#333';
                ctx.fillRect(screenX - 75, this.y - 120, barWidth, barHeight);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(screenX - 75, this.y - 120, barWidth * (this.hp / this.maxHp), barHeight);
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(screenX - 75, this.y - 120, barWidth, barHeight);

                // Draw Segments first (background to head)
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    const seg = this.segments[i];
                    const segScreenX = seg.x - cameraOffset;

                    ctx.save();
                    ctx.translate(segScreenX, seg.y);

                    // Segment Body
                    ctx.fillStyle = i % 2 === 0 ? '#00aa00' : '#008800';
                    ctx.beginPath();
                    ctx.arc(0, 0, 25 - i, 0, Math.PI * 2);
                    ctx.fill();

                    // Spikes
                    ctx.fillStyle = '#555';
                    ctx.beginPath();
                    ctx.moveTo(0, -25);
                    ctx.lineTo(10, -35);
                    ctx.lineTo(-10, -35);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(0, 25);
                    ctx.lineTo(10, 35);
                    ctx.lineTo(-10, 35);
                    ctx.fill();

                    ctx.restore();
                }

                // Draw Head
                ctx.save();
                ctx.translate(screenX, this.y);

                // Head shape
                ctx.fillStyle = '#00cc00';
                ctx.beginPath();
                ctx.ellipse(0, 0, 50, 40, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(-20, -15, 8, 0, Math.PI * 2);
                ctx.arc(-20, 15, 8, 0, Math.PI * 2);
                ctx.fill();

                // Glowing Eyes
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff0000';
                ctx.beginPath();
                ctx.arc(-20, -15, 8, 0, Math.PI * 2);
                ctx.arc(-20, 15, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Teeth
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(-40, -10);
                ctx.lineTo(-30, 0);
                ctx.lineTo(-40, 10);
                ctx.fill();

                ctx.restore();
            }
        }

        // Initialize Boss
        boss = new Boss();

        // Winding tunnel state
        let pathCenter = ROWS / 2;
        let pathDirection = 0;

        const difficultySettings = {
            easy: {
                tunnelWidth: 8,      // Wide tunnel
                changeRate: 0.1,     // Slow changes
                maxChange: 0.5,      // Gentle curves
                obstacleDensity: 0.1 // Low density outside tunnel
            },
            normal: {
                tunnelWidth: 6,
                changeRate: 0.2,
                maxChange: 1.0,
                obstacleDensity: 0.2
            },
            hard: {
                tunnelWidth: 4,
                changeRate: 0.3,
                maxChange: 1.5,
                obstacleDensity: 0.4
            },
            'very-difficult': {
                tunnelWidth: 3,
                changeRate: 0.4,
                maxChange: 2.0,
                obstacleDensity: 0.6
            }
        };

        // System sklepu i punkt√≥w
        let totalCoins = parseInt(localStorage.getItem('snakeCoins') || '0');
        let highScore = parseInt(localStorage.getItem('snakeHighScore') || '0');
        let ownedSkins = JSON.parse(localStorage.getItem('ownedSkins') || '["default1", "default2"]');
        let selectedSkin1 = localStorage.getItem('selectedSkin1') || 'default1';
        let selectedSkin2 = localStorage.getItem('selectedSkin2') || 'default2';
        let selectedTheme = localStorage.getItem('selectedTheme') || 'default';
        let ownedThemes = JSON.parse(localStorage.getItem('ownedThemes') || '["default"]');

        const skins = {
            default1: { name: 'üõ∏ Pink Classic', color: '#ff4d94', price: 0, pattern: 'solid' },
            default2: { name: 'üõ∏ Blue Classic', color: '#4dd4ff', price: 0, pattern: 'solid' },
            green: { name: 'üëΩ Green Martian', color: '#00ff88', price: 50, pattern: 'solid' },
            purple: { name: 'üîÆ Purple Wizard', color: '#bb00ff', price: 50, pattern: 'solid' },
            gold: { name: 'üëë Golden King', color: '#ffd700', price: 100, pattern: 'solid' },
            orange: { name: 'üî• Fiery Comet', color: '#ff8800', price: 100, pattern: 'solid' },
            turquoise: { name: 'üíé Crystal', color: '#40E0D0', price: 100, pattern: 'solid' },
            silver: { name: 'üåü Silver Star', color: '#C0C0C0', price: 150, pattern: 'solid' },
            red: { name: 'üëπ Red Devil', color: '#ff0000', price: 150, pattern: 'solid' },
            cyan: { name: '‚ùÑÔ∏è Icy', color: '#00ffff', price: 150, pattern: 'solid' },
            neonpink: { name: 'üíñ Neon Pink', color: '#ff0099', price: 200, pattern: 'solid' },
            lime: { name: '‚ò¢Ô∏è Radioactive', color: '#ccff00', price: 200, pattern: 'solid' },
            navy: { name: 'üåä Deep Sea', color: '#000099', price: 250, pattern: 'solid' },
            rainbow: { name: 'üåà Rainbow', color: '#ff00ff', price: 300, pattern: 'rainbow' },
            stealth: { name: 'ü•∑ Stealth', color: '#1a1a1a', price: 300, pattern: 'solid' },
            plasma: { name: '‚ö° Plasma', color: '#8800ff', price: 350, pattern: 'solid' },
            cosmic: { name: 'üåå Cosmic', color: '#4a0080', price: 350, pattern: 'solid' },
            ghost: { name: 'üëª Ghost', color: '#88ffff', price: 400, pattern: 'solid' },
            inferno: { name: 'üåã Inferno', color: '#ff3300', price: 400, pattern: 'solid' },
            emerald: { name: 'üíö Emerald', color: '#00cc66', price: 450, pattern: 'solid' },
            royal: { name: 'üëë Royal', color: '#6600cc', price: 500, pattern: 'solid' },
            galaxy: { name: '‚ú® Galactic', color: '#aa00ff', price: 500, pattern: 'solid' }
        };

        const backgroundThemes = {
            default: {
                name: 'üåå Deep Space',
                background: '#0a0a1a',
                gridColor: '#1a1a3a',
                wallColor: '#444466',
                wallDetail: '#555577',
                price: 0,
                description: 'Classic black space'
            },
            nebula: {
                name: 'üå† Nebula',
                background: '#1a0a2e',
                gridColor: '#3a1a5e',
                wallColor: '#6a3a9e',
                wallDetail: '#8a5ade',
                price: 150,
                description: 'Purple nebula'
            },
            mars: {
                name: 'üî¥ Mars',
                background: '#4a1a0a',
                gridColor: '#7a3a2a',
                wallColor: '#aa5a4a',
                wallDetail: '#da8a7a',
                price: 150,
                description: 'Red planet'
            },
            ice: {
                name: '‚ùÑÔ∏è Ice Planet',
                background: '#0a2a3a',
                gridColor: '#1a4a6a',
                wallColor: '#2a6a9a',
                wallDetail: '#4a9aca',
                price: 200,
                description: 'Frozen world'
            },
            alien: {
                name: 'üëΩ Alien Planet',
                background: '#0a2a1a',
                gridColor: '#1a4a3a',
                wallColor: '#2a6a5a',
                wallDetail: '#4a9a8a',
                price: 200,
                description: 'Green alien planet'
            },
            neon: {
                name: 'üåÉ Neon Cosmos',
                background: '#0a0e27',
                gridColor: '#1a2aff',
                wallColor: '#ff00ff',
                wallDetail: '#00ffff',
                price: 250,
                description: 'Cyberpunk in space'
            },
            void: {
                name: 'üï≥Ô∏è Black Hole',
                background: '#000000',
                gridColor: '#1a001a',
                wallColor: '#3a003a',
                wallDetail: '#5a005a',
                price: 300,
                description: 'Absolute darkness'
            },
            solar: {
                name: '‚òÄÔ∏è Solar Corona',
                background: '#3a2a0a',
                gridColor: '#6a5a2a',
                wallColor: '#aa8a4a',
                wallDetail: '#daba7a',
                price: 300,
                description: 'Hot solar plasma'
            },
            galaxy: {
                name: 'üåÄ Galaxy',
                background: '#1a1a3a',
                gridColor: '#3a3a6a',
                wallColor: '#5a5a9a',
                wallDetail: '#8a8aca',
                price: 350,
                description: 'Spiral galaxy'
            },
            wormhole: {
                name: 'üå™Ô∏è Spacetime Tunnel',
                background: '#0a1a2a',
                gridColor: '#2a4a6a',
                wallColor: '#4a7aaa',
                wallDetail: '#6aaaee',
                price: 400,
                description: 'Curved space'
            }
        };

        // ===== LEVEL-BASED BACKGROUND THEMES =====
        const LEVEL_DISTANCE = 1000; // Distance in pixels for each level
        let currentBackgroundLevel = 0;
        let levelTransitionProgress = 0;
        const TRANSITION_DURATION = 300; // pixels over which to transition

        // Array of themes that cycle as you progress
        const levelThemes = [
            { background: '#0a0a1a', gridColor: '#1a1a3a', wallColor: '#444466', wallDetail: '#555577' }, // Deep Space
            { background: '#1a0a2e', gridColor: '#3a1a5e', wallColor: '#6a3a9e', wallDetail: '#8a5ade' }, // Nebula
            { background: '#4a1a0a', gridColor: '#7a3a2a', wallColor: '#aa5a4a', wallDetail: '#da8a7a' }, // Mars
            { background: '#0a2a3a', gridColor: '#1a4a6a', wallColor: '#2a6a9a', wallDetail: '#4a9aca' }, // Ice
            { background: '#0a2a1a', gridColor: '#1a4a3a', wallColor: '#2a6a5a', wallDetail: '#4a9a8a' }, // Alien
            { background: '#0a0e27', gridColor: '#1a2aff', wallColor: '#ff00ff', wallDetail: '#00ffff' }, // Neon
            { background: '#3a2a0a', gridColor: '#6a5a2a', wallColor: '#aa8a4a', wallDetail: '#daba7a' }, // Solar
            { background: '#1a1a3a', gridColor: '#3a3a6a', wallColor: '#5a5a9a', wallDetail: '#8a8aca' }, // Galaxy
            { background: '#000000', gridColor: '#1a001a', wallColor: '#3a003a', wallDetail: '#5a005a' }, // Void
            { background: '#0a1a2a', gridColor: '#2a4a6a', wallColor: '#4a7aaa', wallDetail: '#6aaaee' }  // Wormhole
        ];

        // Color interpolation function
        function lerpColor(color1, color2, t) {
            // Parse hex colors
            const r1 = parseInt(color1.substring(1, 3), 16);
            const g1 = parseInt(color1.substring(3, 5), 16);
            const b1 = parseInt(color1.substring(5, 7), 16);

            const r2 = parseInt(color2.substring(1, 3), 16);
            const g2 = parseInt(color2.substring(3, 5), 16);
            const b2 = parseInt(color2.substring(5, 7), 16);

            // Interpolate
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);

            // Convert back to hex
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        // Get blended theme colors based on current distance
        function getCurrentLevelTheme() {
            const newLevel = Math.floor(distanceTraveled / LEVEL_DISTANCE);
            const distanceIntoLevel = distanceTraveled % LEVEL_DISTANCE;

            // Get current and next theme (cycle through the array)
            const currentTheme = levelThemes[newLevel % levelThemes.length];
            const nextTheme = levelThemes[(newLevel + 1) % levelThemes.length];

            // Check if we're in transition zone (last TRANSITION_DURATION pixels of the level)
            if (distanceIntoLevel >= LEVEL_DISTANCE - TRANSITION_DURATION) {
                // Calculate transition progress (0 to 1)
                const t = (distanceIntoLevel - (LEVEL_DISTANCE - TRANSITION_DURATION)) / TRANSITION_DURATION;

                // Blend colors
                return {
                    background: lerpColor(currentTheme.background, nextTheme.background, t),
                    gridColor: lerpColor(currentTheme.gridColor, nextTheme.gridColor, t),
                    wallColor: lerpColor(currentTheme.wallColor, nextTheme.wallColor, t),
                    wallDetail: lerpColor(currentTheme.wallDetail, nextTheme.wallDetail, t)
                };
            }

            // Not in transition, return current theme
            return currentTheme;
        }

        // ===== PARTICLE SYSTEM =====
        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.active = false;
                this.x = 0;
                this.y = 0;
                this.vx = 0;
                this.vy = 0;
                this.life = 0;
                this.maxLife = 1;
                this.size = 3;
                this.color = '#ffffff';
                this.alpha = 1;
                this.type = 'circle'; // circle, square, star
                this.gravity = 0;
                this.rotation = 0;
                this.rotationSpeed = 0;
            }

            spawn(x, y, vx, vy, life, size, color, type = 'circle') {
                this.active = true;
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.maxLife = life;
                this.size = size;
                this.color = color;
                this.type = type;
                this.alpha = 1;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            }

            update(deltaTime = 1) {
                if (!this.active) return;

                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.vy += this.gravity * deltaTime;
                this.rotation += this.rotationSpeed * deltaTime;

                this.life -= deltaTime;
                this.alpha = Math.max(0, this.life / this.maxLife);

                if (this.life <= 0) {
                    this.active = false;
                }
            }

            draw(ctx, cameraOffset) {
                if (!this.active || this.alpha <= 0) return;

                const screenX = this.x - cameraOffset;
                if (screenX < -50 || screenX > canvasWidth + 50) return;

                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;

                if (this.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(screenX, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'square') {
                    ctx.translate(screenX, this.y);
                    ctx.rotate(this.rotation);
                    ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                } else if (this.type === 'star') {
                    ctx.translate(screenX, this.y);
                    ctx.rotate(this.rotation);
                    this.drawStar(ctx, 0, 0, 5, this.size, this.size / 2);
                }

                ctx.restore();
            }

            drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                const step = Math.PI / spikes;

                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);

                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;

                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }

                ctx.lineTo(cx, cy - outerRadius);
                ctx.closePath();
                ctx.fill();
            }
        }

        class ParticleSystem {
            constructor(poolSize = 500) {
                this.particles = [];
                for (let i = 0; i < poolSize; i++) {
                    this.particles.push(new Particle());
                }
            }

            emit(x, y, vx, vy, life, size, color, type = 'circle') {
                for (let particle of this.particles) {
                    if (!particle.active) {
                        particle.spawn(x, y, vx, vy, life, size, color, type);
                        return particle;
                    }
                }
                return null;
            }

            burst(x, y, count, color, speed = 3, life = 30, size = 4, type = 'circle') {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                    const velocity = speed * (0.5 + Math.random() * 0.5);
                    this.emit(
                        x, y,
                        Math.cos(angle) * velocity,
                        Math.sin(angle) * velocity,
                        life * (0.7 + Math.random() * 0.6),
                        size * (0.7 + Math.random() * 0.6),
                        color,
                        type
                    );
                }
            }

            trail(x, y, color, size = 3, life = 20, type = 'circle') {
                this.emit(x, y, 0, 0, life, size, color, type);
            }

            update(deltaTime = 1) {
                for (let particle of this.particles) {
                    if (particle.active) {
                        particle.update(deltaTime);
                    }
                }
            }

            draw(ctx, cameraOffset) {
                for (let particle of this.particles) {
                    if (particle.active) {
                        particle.draw(ctx, cameraOffset);
                    }
                }
            }

            clear() {
                for (let particle of this.particles) {
                    particle.active = false;
                }
            }
        }

        // Initialize particle system
        let particleSystem = new ParticleSystem(500);

        // Screen shake system
        let screenShake = {
            x: 0,
            y: 0,
            intensity: 0,
            duration: 0
        };

        function applyScreenShake(intensity, duration) {
            screenShake.intensity = intensity;
            screenShake.duration = duration;
        }

        function updateScreenShake() {
            if (screenShake.duration > 0) {
                screenShake.duration--;
                const shake = screenShake.intensity * (screenShake.duration / 20);
                screenShake.x = (Math.random() - 0.5) * shake * 2;
                screenShake.y = (Math.random() - 0.5) * shake * 2;
            } else {
                screenShake.x = 0;
                screenShake.y = 0;
            }
        }

        let snake1 = {
            body: [{ x: 5, y: 10 }],
            direction: { x: 1, y: 0 },
            nextDirection: { x: 1, y: 0 },
            score: 0,
            alive: true,
            lives: 3,
            invulnerableUntil: 0,
            color: skins[selectedSkin1].color,
            fruitsEaten: 0,
            speed: 1.0,
            bobOffset: 0, // For UFO floating animation
            tiltAngle: 0  // For UFO tilting
        };

        let snake2 = {
            body: [{ x: 5, y: 20 }],
            direction: { x: 1, y: 0 },
            nextDirection: { x: 1, y: 0 },
            score: 0,
            alive: true,
            lives: 3,
            invulnerableUntil: 0,
            color: skins[selectedSkin2].color,
            fruitsEaten: 0,
            speed: 1.0,
            bobOffset: 0,
            tiltAngle: 0
        };

        let maze = [];
        let fruits = [];
        let mazeWidth = 50;
        let lastGeneratedColumn = 50;

        function showConfirmModal(message, onConfirm) {
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmModal').style.display = 'flex';
            confirmCallback = onConfirm;
        }

        function hideConfirmModal() {
            const wasGamePaused = gamePaused;
            document.getElementById('confirmModal').style.display = 'none';
            confirmCallback = null;

            // Je≈õli gra by≈Ça zapauzowana i gracz kliknƒÖ≈Ç NIE, wzn√≥w z countdown
            if (wasGamePaused && gameRunning) {
                // Resume music when returning to game
                const backgroundMusic = document.getElementById('backgroundMusic');
                if (backgroundMusic && !backgroundMusic.muted) {
                    backgroundMusic.play().catch(e => console.log('Could not resume music:', e));
                }

                resumeCountdown = 3;
                resumeCountdownStart = Date.now();
                // Nie odpauzuj od razu - countdown siƒô tym zajmie
            }
        }

        function updateCoinDisplay() {
            document.getElementById('totalCoins').textContent = totalCoins;
            document.getElementById('shopCoins').textContent = totalCoins;
        }

        function saveProgress() {
            localStorage.setItem('snakeCoins', totalCoins.toString());
            localStorage.setItem('snakeHighScore', highScore.toString());
            localStorage.setItem('ownedSkins', JSON.stringify(ownedSkins));
            localStorage.setItem('selectedSkin1', selectedSkin1);
            localStorage.setItem('selectedSkin2', selectedSkin2);
            localStorage.setItem('selectedTheme', selectedTheme);
            localStorage.setItem('ownedThemes', JSON.stringify(ownedThemes));
        }

        function openShop() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('shopScreen').style.display = 'block';
            currentShopPlayer = 1;
            updateCoinDisplay();

            // Resetuj zak≈Çadki
            document.getElementById('skinsContainer').style.display = 'grid';
            document.getElementById('themesContainer').style.display = 'none';
            document.querySelectorAll('.shop-tab').forEach((tab, idx) => {
                tab.classList.toggle('active', idx === 0);
            });
            document.querySelectorAll('.player-select').forEach((tab, idx) => {
                tab.classList.toggle('active', idx === 0);
            });

            renderShop();
        }

        function closeShop() {
            document.getElementById('shopScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
        }

        // ===== LEADERBOARD SYSTEM =====
        let leaderboard = [];
        let pendingHighScore = null;

        async function loadLeaderboard() {
            // Priority 1: Try to load from Supabase (global leaderboard)
            if (supabaseAvailable) {
                try {
                    const { data, error } = await supabase
                        .from('leaderboard')
                        .select('*')
                        .order('score', { ascending: false })
                        .limit(100); // Top 100 scores globally

                    if (error) throw error;

                    if (data && data.length > 0) {
                        // Transform Supabase data to local format
                        leaderboard = data.map(entry => ({
                            name: entry.player_name,
                            score: entry.score,
                            mode: entry.game_mode,
                            date: new Date(entry.play_date).toLocaleDateString('en-US')
                        }));

                        // Update localStorage cache for offline access
                        localStorage.setItem('snakeLeaderboard', JSON.stringify(leaderboard));
                        console.log(`üìä Loaded ${data.length} entries from Supabase`);
                        return;
                    }
                } catch (error) {
                    console.error('‚ö†Ô∏è Supabase load failed, falling back to localStorage:', error);
                }
            }

            // Priority 2: Fallback to localStorage (offline mode)
            const saved = localStorage.getItem('snakeLeaderboard');
            if (saved) {
                leaderboard = JSON.parse(saved);
                console.log(`üì¶ Loaded ${leaderboard.length} entries from localStorage`);
            } else {
                leaderboard = [];
            }
        }

        function saveLeaderboard() {
            localStorage.setItem('snakeLeaderboard', JSON.stringify(leaderboard));
        }

        function isHighScore(score) {
            // With global leaderboard, allow all submissions
            if (supabaseAvailable) {
                return true;  // Every score contributes to global leaderboard
            }

            // Fallback: Local top 10 logic when offline
            if (leaderboard.length < 10) return true;
            return score > leaderboard[leaderboard.length - 1].score;
        }

        async function addToLeaderboard(name, score, mode) {
            const entry = {
                name: name || 'Anonim',
                score: score,
                mode: mode,
                date: new Date().toLocaleDateString('en-US')
            };

            // Add to local array immediately (optimistic UI update)
            leaderboard.push(entry);
            leaderboard.sort((a, b) => b.score - a.score);

            // Save to localStorage immediately (no waiting)
            saveLeaderboard();

            // Try to save to Supabase asynchronously (non-blocking)
            if (supabaseAvailable) {
                try {
                    const { data, error } = await supabase
                        .from('leaderboard')
                        .insert([{
                            player_name: entry.name,
                            score: entry.score,
                            game_mode: entry.mode,
                            play_date: new Date().toISOString()
                        }])
                        .select();

                    if (error) throw error;

                    console.log('‚úÖ Score saved to Supabase:', data);

                    // Reload leaderboard from Supabase to get latest global rankings
                    await loadLeaderboard();

                    // Update display if leaderboard screen is visible
                    if (document.getElementById('leaderboardScreen').style.display === 'block') {
                        renderLeaderboard();
                    }
                } catch (error) {
                    console.error('‚ùå Error saving to Supabase:', error);
                    // Score is still saved locally - game continues normally
                }
            }
        }

        async function openLeaderboard() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('leaderboardScreen').style.display = 'block';

            // Show loading state
            const container = document.getElementById('leaderboardEntries');
            container.innerHTML = '<p style="color: #8af3ff; padding: 30px;">üì° Loading leaderboard...</p>';

            // Load latest data from Supabase
            await loadLeaderboard();

            // Render updated leaderboard
            renderLeaderboard();
        }

        function closeLeaderboard() {
            document.getElementById('leaderboardScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
        }

        function renderLeaderboard() {
            const container = document.getElementById('leaderboardEntries');
            container.innerHTML = '';

            if (leaderboard.length === 0) {
                container.innerHTML = '<p style="color: #8af3ff; padding: 30px;">No scores. Be first!</p>';
                return;
            }

            // Show top 50 entries (expanded from 10 for global leaderboard)
            const displayEntries = leaderboard.slice(0, 50);

            displayEntries.forEach((entry, index) => {
                const rank = index + 1;
                const entryDiv = document.createElement('div');
                entryDiv.className = 'leaderboard-entry' + (rank <= 3 ? ' top3' : '');

                let rankClass = '';
                let rankEmoji = '';
                if (rank === 1) { rankClass = 'gold'; rankEmoji = 'ü•á '; }
                else if (rank === 2) { rankClass = 'silver'; rankEmoji = 'ü•à '; }
                else if (rank === 3) { rankClass = 'bronze'; rankEmoji = 'ü•â '; }

                const modeText = entry.mode === 'solo' ? 'Solo' : 'Multiplayer';
                const modeClass = entry.mode === 'solo' ? 'solo' : 'multiplayer';

                entryDiv.innerHTML = `
                    <div class="rank-col ${rankClass}">${rankEmoji}${rank}.</div>
                    <div class="name-col">${entry.name}</div>
                    <div class="score-col">${entry.score} pkt</div>
                    <div class="mode-col"><span class="mode-badge ${modeClass}">${modeText}</span></div>
                `;

                container.appendChild(entryDiv);
            });

            // Add global leaderboard indicator
            if (supabaseAvailable && leaderboard.length > 0) {
                const globalIndicator = document.createElement('p');
                globalIndicator.style.cssText = 'color: #ffd700; margin-top: 20px; font-size: 0.9em; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);';
                globalIndicator.innerHTML = `üåç Global leaderboard - showing ${displayEntries.length} of ${leaderboard.length} top players`;
                container.appendChild(globalIndicator);
            } else if (!supabaseAvailable) {
                const offlineIndicator = document.createElement('p');
                offlineIndicator.style.cssText = 'color: #ff8a80; margin-top: 20px; font-size: 0.9em;';
                offlineIndicator.innerHTML = `üì¶ Offline mode - local leaderboard`;
                container.appendChild(offlineIndicator);
            }
        }

        function showNameEntryModal(score, mode) {
            pendingHighScore = { score, mode };
            document.getElementById('newHighScore').textContent = score;
            document.getElementById('nameEntryModal').style.display = 'flex';
            document.getElementById('playerNameInput').value = '';
            document.getElementById('playerNameInput').focus();
        }

        async function saveHighScore() {
            const name = document.getElementById('playerNameInput').value.trim();
            if (pendingHighScore) {
                await addToLeaderboard(name, pendingHighScore.score, pendingHighScore.mode);
                pendingHighScore = null;
            }
            document.getElementById('nameEntryModal').style.display = 'none';
        }

        async function skipHighScore() {
            if (pendingHighScore) {
                await addToLeaderboard('Anonim', pendingHighScore.score, pendingHighScore.mode);
                pendingHighScore = null;
            }
            document.getElementById('nameEntryModal').style.display = 'none';
        }

        // Handle Enter key in name input
        document.addEventListener('DOMContentLoaded', function () {
            const nameInput = document.getElementById('playerNameInput');
            if (nameInput) {
                nameInput.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        saveHighScore();
                    }
                });
            }

            // Auto-detect mobile and select mode, else desktop
            if (isMobile) {
                console.log("üì± Mobile device detected - auto-selecting mobile mode");
                selectMobileMode();
            } else {
                console.log("üñ•Ô∏è Desktop device detected - auto-selecting desktop mode");
                selectDesktopMode();
            }

            // Mouse tracking for Boss Battle
            document.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseX = (e.clientX - rect.left) / (rect.width / canvasWidth);
                mouseY = (e.clientY - rect.top) / (rect.height / canvasHeight);
            });

            // Shooting for Boss Battle
            document.addEventListener('mousedown', (e) => {
                if (gameRunning && bossActive && !gamePaused) {
                    const now = Date.now();
                    if (playerAmmo > 0 && now - lastRocketReload > 500) { // Global cooldown 0.5s prevent instant spam
                        // Fire rocket
                        const rect = canvas.getBoundingClientRect();
                        const targetX = (e.clientX - rect.left) / (rect.width / canvasWidth) + cameraOffset;
                        const targetY = (e.clientY - rect.top) / (rect.height / canvasHeight);

                        // Spawn rocket from player position
                        // Try to find active player
                        let sourceX = 0, sourceY = 0;
                        if (snake1.alive) {
                            const head = snake1.body[0];
                            sourceX = head.x * GRID_SIZE + GRID_SIZE / 2;
                            sourceY = head.y * GRID_SIZE + GRID_SIZE / 2;
                        } else if (snake2.alive) {
                            const head = snake2.body[0];
                            sourceX = head.x * GRID_SIZE + GRID_SIZE / 2;
                            sourceY = head.y * GRID_SIZE + GRID_SIZE / 2;
                        } else {
                            return;
                        }

                        rockets.push(new Rocket(sourceX, sourceY, targetX, targetY));
                        playerAmmo--;
                        // Play sound effect (optional/stub)
                    }
                }
            });
        });

        function selectShopTab(tab) {
            const shopTabs = document.querySelectorAll('.shop-tab');
            shopTabs.forEach(t => t.classList.remove('active'));

            if (tab === 'skins') {
                shopTabs[0].classList.add('active');
                document.getElementById('skinsContainer').style.display = 'grid';
                document.getElementById('themesContainer').style.display = 'none';
                renderShop();
            } else if (tab === 'themes') {
                shopTabs[1].classList.add('active');
                document.getElementById('skinsContainer').style.display = 'none';
                document.getElementById('themesContainer').style.display = 'grid';
                renderThemes();
            }
        }

        // Reset mode selection UI
        function resetModeSelection() {
            controlMode = null;
            modeSelected = false;
            document.querySelector('.desktop-mode-btn')?.classList.remove('selected');
            document.querySelector('.mobile-mode-btn')?.classList.remove('selected');
            document.getElementById('gameOptions').style.display = 'none';
            document.getElementById('modeSelection').style.display = 'block';
        }

        function backToMenu() {
            showConfirmModal('Are you sure you want to return to main menu?', () => {
                // Stop and reset background music
                const backgroundMusic = document.getElementById('backgroundMusic');
                if (backgroundMusic) {
                    backgroundMusic.pause();
                    backgroundMusic.currentTime = 0;
                }

                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'none';
                document.getElementById('startScreen').style.display = 'block';
                resetModeSelection();
                updateCoinDisplay();
            });
        }

        function exitToMenu() {
            // Zatrzymaj grƒô (pauza)
            gamePaused = true;

            // Stop music IMMEDIATELY when Q is pressed
            const backgroundMusic = document.getElementById('backgroundMusic');
            if (backgroundMusic) {
                backgroundMusic.pause();
            }

            showConfirmModal('Are you sure you want to return to menu? You will lose progress!', () => {
                // Je≈õli TAK - zako≈Ñcz grƒô
                gameRunning = false;
                gamePaused = false;

                // Reset background music position
                if (backgroundMusic) {
                    backgroundMusic.currentTime = 0;
                }

                // Clear particles
                particleSystem.clear();

                // Hide game container
                document.getElementById('gameContainer').style.display = 'none';

                // Show main menu
                document.getElementById('startScreen').style.display = 'block';
                resetModeSelection();

                // Update coin display
                updateCoinDisplay();
            });
        }

        function selectPlayerTab(player) {
            currentShopPlayer = player;
            document.querySelectorAll('.player-select').forEach((tab, idx) => {
                tab.classList.toggle('active', idx + 1 === player);
            });
            renderShop();
        }

        function renderShop() {
            const container = document.getElementById('skinsContainer');
            container.innerHTML = '';

            const currentSkin = currentShopPlayer === 1 ? selectedSkin1 : selectedSkin2;

            for (const [id, skin] of Object.entries(skins)) {
                const owned = ownedSkins.includes(id);
                const selected = currentSkin === id;

                const card = document.createElement('div');
                card.className = `skin-card ${owned ? 'owned' : ''} ${selected ? 'selected' : ''}`;

                const preview = document.createElement('div');
                preview.className = 'skin-preview';
                preview.style.background = skin.color;

                const name = document.createElement('div');
                name.className = 'skin-name';
                name.textContent = skin.name;

                const price = document.createElement('div');
                price.className = 'skin-price';
                price.textContent = owned ? '‚úì Owned' : `üí∞ ${skin.price}`;

                card.appendChild(preview);
                card.appendChild(name);
                card.appendChild(price);

                if (!owned && skin.price > 0) {
                    const buyBtn = document.createElement('button');
                    buyBtn.className = 'buy-btn';
                    buyBtn.textContent = 'BUY';
                    buyBtn.disabled = totalCoins < skin.price;
                    buyBtn.onclick = () => buySkin(id);
                    card.appendChild(buyBtn);
                } else if (owned && !selected) {
                    const selectBtn = document.createElement('button');
                    selectBtn.className = 'select-btn';
                    selectBtn.textContent = 'SELECT';
                    selectBtn.onclick = () => selectSkin(id);
                    card.appendChild(selectBtn);
                } else if (selected) {
                    const selectedText = document.createElement('div');
                    selectedText.style.color = '#667eea';
                    selectedText.style.fontWeight = 'bold';
                    selectedText.style.marginTop = '10px';
                    selectedText.textContent = '‚úì SELECTED';
                    card.appendChild(selectedText);
                }

                container.appendChild(card);
            }
        }

        function buySkin(skinId) {
            const skin = skins[skinId];
            if (totalCoins >= skin.price && !ownedSkins.includes(skinId)) {
                totalCoins -= skin.price;
                ownedSkins.push(skinId);
                saveProgress();
                updateCoinDisplay();
                renderShop();
            }
        }

        function selectSkin(skinId) {
            if (currentShopPlayer === 1) {
                selectedSkin1 = skinId;
            } else {
                selectedSkin2 = skinId;
            }
            saveProgress();
            renderShop();
        }

        function renderThemes() {
            const container = document.getElementById('themesContainer');
            container.innerHTML = '';

            for (const [id, theme] of Object.entries(backgroundThemes)) {
                const owned = ownedThemes.includes(id);
                const selected = selectedTheme === id;

                const card = document.createElement('div');
                card.className = `skin-card ${owned ? 'owned' : ''} ${selected ? 'selected' : ''}`;

                const preview = document.createElement('div');
                preview.className = 'skin-preview';
                preview.style.background = `linear-gradient(135deg, ${theme.background} 0%, ${theme.wallColor} 100%)`;
                preview.style.border = `3px solid ${theme.wallColor}`;

                const name = document.createElement('div');
                name.className = 'skin-name';
                name.textContent = theme.name;

                const description = document.createElement('div');
                description.style.fontSize = '0.9em';
                description.style.color = '#666';
                description.style.margin = '5px 0';
                description.textContent = theme.description;

                const price = document.createElement('div');
                price.className = 'skin-price';
                price.textContent = owned ? '‚úì Owned' : `üí∞ ${theme.price}`;

                card.appendChild(preview);
                card.appendChild(name);
                card.appendChild(description);
                card.appendChild(price);

                if (!owned && theme.price > 0) {
                    const buyBtn = document.createElement('button');
                    buyBtn.className = 'buy-btn';
                    buyBtn.textContent = 'BUY';
                    buyBtn.disabled = totalCoins < theme.price;
                    buyBtn.onclick = () => buyTheme(id);
                    card.appendChild(buyBtn);
                } else if (owned && !selected) {
                    const selectBtn = document.createElement('button');
                    selectBtn.className = 'select-btn';
                    selectBtn.textContent = 'SELECT';
                    selectBtn.onclick = () => selectTheme(id);
                    card.appendChild(selectBtn);
                } else if (selected) {
                    const selectedText = document.createElement('div');
                    selectedText.style.color = '#667eea';
                    selectedText.style.fontWeight = 'bold';
                    selectedText.style.marginTop = '10px';
                    selectedText.textContent = '‚úì WYBRANE';
                    card.appendChild(selectedText);
                }

                container.appendChild(card);
            }
        }

        function buyTheme(themeId) {
            const theme = backgroundThemes[themeId];
            if (totalCoins >= theme.price && !ownedThemes.includes(themeId)) {
                totalCoins -= theme.price;
                ownedThemes.push(themeId);
                saveProgress();
                updateCoinDisplay();
                renderThemes();
            }
        }

        function selectTheme(themeId) {
            selectedTheme = themeId;
            saveProgress();
            renderThemes();
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function updateLivesDisplay() {
            const hearts = '‚ù§Ô∏è';
            document.getElementById('lives1').textContent = hearts.repeat(snake1.lives);
            if (gameMode === 'multiplayer') {
                document.getElementById('lives2').textContent = hearts.repeat(snake2.lives);
            }
            // Update mobile overlay if in mobile mode
            updateMobileScoreOverlay();
        }

        // Update mobile score overlay
        function updateMobileScoreOverlay() {
            if (!document.documentElement.classList.contains('mobile-fullscreen-mode')) return;

            const overlayScore = document.getElementById('overlayScore');
            const overlayLives = document.getElementById('overlayLives');

            if (overlayScore && snake1) {
                overlayScore.textContent = snake1.score;
            }

            if (overlayLives && snake1) {
                overlayLives.textContent = '‚ù§Ô∏è'.repeat(snake1.lives);
            }
        }

        function makeInvulnerable(snake) {
            // Give 3 seconds of invulnerability
            snake.invulnerableUntil = Date.now() + 3000;
        }

        function isInvulnerable(snake) {
            return Date.now() < snake.invulnerableUntil;
        }

        function generateMaze() {
            maze = [];
            lastGeneratedColumn = mazeWidth;

            // Reset path state
            pathCenter = ROWS / 2;
            pathDirection = 0;

            // Generuj poczƒÖtkowƒÖ mapƒô u≈ºywajƒÖc tej samej logiki
            for (let x = 0; x < mazeWidth; x++) {
                generateMazeColumn(x);
            }

            // PoczƒÖtkowa bezpieczna strefa (pierwsze 15 kolumn bez przeszk√≥d)
            for (let x = 0; x < 15; x++) {
                for (let y = 1; y < ROWS - 1; y++) {
                    maze[x][y] = 0;
                }
            }

            // Dodaj poczƒÖtkowe owoce
            fruits = [];
            for (let i = 0; i < 30; i++) {
                let x = Math.floor(Math.random() * (mazeWidth - 20)) + 15;
                let y = Math.floor(Math.random() * (ROWS - 4)) + 2;
                if (maze[x] && maze[x][y] === 0) {
                    fruits.push({
                        x: x,
                        y: y,
                        type: Math.floor(Math.random() * 3)
                    });
                }
            }
        }

        function generateMazeColumn(x) {
            if (!maze[x]) {
                maze[x] = [];
            }

            // Initialize all cells
            for (let y = 0; y < ROWS; y++) {
                maze[x][y] = 0;
            }

            // Top and bottom walls always present
            maze[x][0] = 1;
            maze[x][ROWS - 1] = 1;

            // Generate obstacles after the safe starting zone
            if (x > 15) {
                const settings = difficultySettings[currentDifficulty];

                // Update path center
                // Randomly change direction slightly
                pathDirection += (Math.random() - 0.5) * settings.changeRate;

                // Clamp direction change to prevent too sharp turns
                pathDirection = Math.max(-settings.maxChange, Math.min(settings.maxChange, pathDirection));

                // Apply direction to center
                pathCenter += pathDirection;

                // Keep path within bounds (with padding)
                const padding = settings.tunnelWidth / 2 + 2;
                if (pathCenter < padding) {
                    pathCenter = padding;
                    pathDirection *= -0.5; // Bounce back
                } else if (pathCenter > ROWS - padding) {
                    pathCenter = ROWS - padding;
                    pathDirection *= -0.5; // Bounce back
                }

                const tunnelTop = pathCenter - settings.tunnelWidth / 2;
                const tunnelBottom = pathCenter + settings.tunnelWidth / 2;

                for (let y = 1; y < ROWS - 1; y++) {
                    // Check if inside tunnel
                    if (y >= tunnelTop && y <= tunnelBottom) {
                        // Safe zone - no obstacles
                        maze[x][y] = 0;
                    } else {
                        // Outside tunnel - high chance of obstacles
                        if (Math.random() < settings.obstacleDensity) {
                            maze[x][y] = 1;
                        }
                    }
                }
            }

            // Generate fruits (mostly inside the tunnel)
            if (Math.random() < 0.35 && x > 15) {
                const settings = difficultySettings[currentDifficulty];
                let attempts = 0;
                while (attempts < 5) {
                    // Try to spawn near the path center for playability
                    const offset = (Math.random() - 0.5) * settings.tunnelWidth;
                    let y = Math.floor(pathCenter + offset);

                    // Clamp y
                    y = Math.max(1, Math.min(ROWS - 2, y));

                    if (maze[x][y] === 0) {
                        fruits.push({
                            x: x,
                            y: y,
                            type: Math.floor(Math.random() * 3)
                        });
                        break;
                    }
                    attempts++;
                }
            }
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';

            // Get selected game mode and difficulty
            gameMode = document.getElementById('gameModeSelect').value;
            currentDifficulty = document.getElementById('difficultySelect').value;
            distanceTraveled = 0;

            // Set Boss Spawn Distance
            if (gameMode === 'boss') {
                distToBoss = 500; // Start almost immediately
                bossActive = false; // Reset to ensure it spawns fresh
                // Create a clean boss instance
                boss = new Boss();
            } else {
                distToBoss = 2000;
                bossActive = false;
                boss = new Boss();
            }

            // Camera delay setup
            gameStartTime = Date.now();
            cameraStarted = false;

            // Reset pause state
            gamePaused = false;
            resumeCountdown = 0;

            gameRunning = true;
            cameraOffset = 0;
            maxProgressX = 0;
            maxSpeedAchieved = 1.0;
            scrollSpeed = 0.9;
            lastUpdateTime1 = 0;
            lastUpdateTime2 = 0;
            lastFrameTime = performance.now();
            lastGeneratedColumn = mazeWidth;

            // Reset path state
            pathCenter = ROWS / 2;
            pathDirection = 0;

            // Set lives based on game mode
            const livesCount = 3; // Always 3 lives, even in solo mode (User Request)

            snake1 = {
                body: [{ x: 5, y: 10 }],
                direction: { x: 1, y: 0 },
                nextDirection: { x: 1, y: 0 },
                score: 0,
                alive: true,
                lives: livesCount,
                invulnerableUntil: 0,
                color: skins[selectedSkin1].color,
                fruitsEaten: 0,
                speed: 1.0
            };

            snake2 = {
                body: [{ x: 5, y: 20 }],
                direction: { x: 1, y: 0 },
                nextDirection: { x: 1, y: 0 },
                score: 0,
                alive: true,
                lives: 3,  // Bot ma 3 ≈ºycia
                invulnerableUntil: 0,
                color: skins[selectedSkin2].color,
                fruitsEaten: 0,
                speed: 1.0
            };

            // Hide player 2 info in solo mode
            if (gameMode === 'solo') {
                document.getElementById('player2Info').style.display = 'none';
                document.getElementById('player1Info').querySelector('div').innerHTML = 'Solo <span id="lives1">‚ù§Ô∏è</span>';
            } else {
                document.getElementById('player2Info').style.display = 'flex';
                document.getElementById('player1Info').querySelector('div').innerHTML = 'Player 1 <span id="lives1">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>';
                document.getElementById('player2Info').querySelector('div').innerHTML = 'Player 2 <span id="lives2">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>';
            }

            updateLivesDisplay();
            generateMaze();

            // Start background music
            const backgroundMusic = document.getElementById('backgroundMusic');
            if (backgroundMusic && !backgroundMusic.muted) {
                backgroundMusic.play().catch(e => console.log('Audio autoplay prevented:', e));
            }

            requestAnimationFrame(gameLoop);
        }

        function restartGame() {
            showConfirmModal('Are you sure you want to start a new game?', () => {
                document.getElementById('gameOver').style.display = 'none';
                startGame();
            });
        }

        function updateSnake(snake) {
            if (!snake.alive) return;

            // Use nextDirection persistently
            snake.direction = snake.nextDirection;

            let head = {
                x: snake.body[0].x + snake.direction.x,
                y: snake.body[0].y + snake.direction.y
            };

            // Check collision with walls/obstacles (only if not invulnerable)
            if (!isInvulnerable(snake)) {
                let collision = false;
                if (head.y < 0 || head.y >= ROWS ||
                    (maze[Math.floor(head.x)] && maze[Math.floor(head.x)][head.y] === 1)) {
                    collision = true;
                }

                // Check self-collision (exclude tail since it will be removed)
                for (let i = 0; i < snake.body.length - 1; i++) {
                    let segment = snake.body[i];
                    if (head.x === segment.x && head.y === segment.y) {
                        collision = true;
                        break;
                    }
                }

                if (collision) {
                    snake.lives--;
                    updateLivesDisplay();

                    // Collision particle explosion
                    const explosionX = head.x * GRID_SIZE + GRID_SIZE / 2;
                    const explosionY = head.y * GRID_SIZE + GRID_SIZE / 2;
                    particleSystem.burst(explosionX, explosionY, 20, '#ff6600', 4, 40, 5, 'square');
                    particleSystem.burst(explosionX, explosionY, 15, '#ffff00', 3, 35, 4, 'star');
                    applyScreenShake(8, 15);

                    if (snake.lives > 0) {
                        // Make invulnerable
                        makeInvulnerable(snake);
                    } else {
                        // Die permanently - big explosion
                        particleSystem.burst(explosionX, explosionY, 40, '#ff0000', 6, 60, 7, 'circle');
                        particleSystem.burst(explosionX, explosionY, 30, snake.color, 5, 50, 6, 'star');
                        applyScreenShake(15, 25);
                        snake.alive = false;
                        return;
                    }
                }
            }

            // Check fruit collection
            for (let i = fruits.length - 1; i >= 0; i--) {
                if (Math.floor(head.x) === fruits[i].x && head.y === fruits[i].y) {
                    snake.score += 10;

                    // Collection particle burst effect
                    const collectX = fruits[i].x * GRID_SIZE + GRID_SIZE / 2;
                    const collectY = fruits[i].y * GRID_SIZE + GRID_SIZE / 2;
                    const crystalColors = ['#ff00ff', '#00ffff', '#ffff00'];
                    const fruitColor = crystalColors[fruits[i].type];

                    // Burst effect
                    particleSystem.burst(collectX, collectY, 25, fruitColor, 3, 35, 5, 'star');
                    particleSystem.burst(collectX, collectY, 15, '#ffffff', 2, 25, 3, 'circle');

                    // Tractor beam pull effect
                    for (let j = 0; j < 10; j++) {
                        const angle = Math.random() * Math.PI * 2;
                        particleSystem.emit(
                            collectX + Math.cos(angle) * 20,
                            collectY + Math.sin(angle) * 20,
                            -Math.cos(angle) * 2,
                            -Math.sin(angle) * 2,
                            15,
                            3,
                            fruitColor,
                            'circle'
                        );
                    }

                    applyScreenShake(3, 8);

                    fruits.splice(i, 1);
                    snake.body.unshift(head);

                    // Increase snake speed when eating fruit
                    snake.fruitsEaten++;
                    snake.speed = 1.0 + (snake.fruitsEaten * 0.1); // Speed increases by 10% per fruit

                    return;
                }
            }

            snake.body.unshift(head);
            snake.body.pop();
        }


        // ===== PARALLAX BACKGROUND SYSTEM =====
        class ParallaxLayer {
            constructor(speed, color, type, density = 50) {
                this.speed = speed;
                this.color = color;
                this.type = type; // 'stars', 'nebula', 'grid'
                this.density = density;
                this.elements = [];
                this.initialize();
            }

            initialize() {
                if (this.type === 'stars') {
                    for (let i = 0; i < this.density; i++) {
                        this.elements.push({
                            x: Math.random() * canvasWidth * 3,
                            y: Math.random() * canvasHeight,
                            size: Math.random() * 2 + 0.5,
                            twinklePhase: Math.random() * Math.PI * 2,
                            twinkleSpeed: 0.02 + Math.random() * 0.03
                        });
                    }
                } else if (this.type === 'nebula') {
                    for (let i = 0; i < 5; i++) {
                        this.elements.push({
                            x: Math.random() * canvasWidth * 2,
                            y: Math.random() * canvasHeight,
                            size: 100 + Math.random() * 200,
                            alpha: 0.1 + Math.random() * 0.2
                        });
                    }
                }
            }

            update(cameraOffset) {
                if (this.type === 'stars') {
                    for (let star of this.elements) {
                        star.twinklePhase += star.twinkleSpeed;
                        // Wrap stars around
                        if (star.x < cameraOffset * this.speed - 100) {
                            star.x += canvasWidth * 2;
                        }
                    }
                }
            }

            draw(ctx, cameraOffset, time) {
                if (this.type === 'stars') {
                    ctx.fillStyle = this.color;
                    for (let star of this.elements) {
                        const screenX = star.x - (cameraOffset * this.speed);
                        if (screenX > -10 && screenX < canvasWidth + 10) {
                            const twinkle = Math.sin(star.twinklePhase) * 0.3 + 0.7;
                            ctx.globalAlpha = twinkle;
                            ctx.beginPath();
                            ctx.arc(screenX, star.y, star.size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    ctx.globalAlpha = 1;
                } else if (this.type === 'nebula') {
                    for (let nebula of this.elements) {
                        const screenX = nebula.x - (cameraOffset * this.speed);
                        if (screenX > -nebula.size && screenX < canvasWidth + nebula.size) {
                            const gradient = ctx.createRadialGradient(
                                screenX, nebula.y, 0,
                                screenX, nebula.y, nebula.size
                            );
                            gradient.addColorStop(0, this.color + '40');
                            gradient.addColorStop(1, this.color + '00');
                            ctx.fillStyle = gradient;
                            ctx.globalAlpha = nebula.alpha;
                            ctx.fillRect(screenX - nebula.size, nebula.y - nebula.size,
                                nebula.size * 2, nebula.size * 2);
                        }
                    }
                    ctx.globalAlpha = 1;
                }
            }
        }

        // Initialize parallax layers
        let parallaxLayers = [
            new ParallaxLayer(0.1, '#ffffff', 'stars', 30),     // Far stars
            new ParallaxLayer(0.3, '#8888ff', 'nebula', 5),     // Distant nebula
            new ParallaxLayer(0.5, '#ffffff', 'stars', 50),     // Mid stars
            new ParallaxLayer(0.7, '#ff88ff', 'nebula', 3),     // Close nebula
            new ParallaxLayer(0.9, '#ffffff', 'stars', 70)      // Close stars
        ];

        function draw() {
            // Use level-based theme during gameplay, shop theme otherwise
            const theme = (gameRunning && distanceTraveled > 0)
                ? getCurrentLevelTheme()
                : backgroundThemes[selectedTheme];
            const currentTime = Date.now();

            // Apply screen shake
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);

            // Draw space background
            ctx.fillStyle = theme.background;
            ctx.fillRect(-screenShake.x, -screenShake.y, canvasWidth, canvasHeight);

            // Draw parallax layers
            for (let layer of parallaxLayers) {
                layer.update(cameraOffset);
                layer.draw(ctx, cameraOffset, currentTime);
            }

            ctx.strokeStyle = theme.gridColor;
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * GRID_SIZE, 0);
                ctx.lineTo(x * GRID_SIZE, canvasHeight);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * GRID_SIZE);
                ctx.lineTo(canvasWidth, y * GRID_SIZE);
                ctx.stroke();
            }

            // Draw asteroids/space rocks
            for (let x = 0; x < COLS + 5; x++) {
                let mazeX = Math.floor(cameraOffset / GRID_SIZE) + x;
                if (maze[mazeX]) {
                    for (let y = 0; y < ROWS; y++) {
                        if (maze[mazeX][y] === 1) {
                            let screenX = x * GRID_SIZE - (cameraOffset % GRID_SIZE) + GRID_SIZE / 2;
                            let screenY = y * GRID_SIZE + GRID_SIZE / 2;

                            // Draw asteroid with irregular shape
                            ctx.save();

                            // Shadow/glow for depth
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = theme.wallColor;

                            // Main asteroid body
                            const size = GRID_SIZE * 0.85;
                            const gradient = ctx.createRadialGradient(
                                screenX - 2, screenY - 2, 0,
                                screenX, screenY, size / 2
                            );
                            gradient.addColorStop(0, '#888888');
                            gradient.addColorStop(0.7, theme.wallColor);
                            gradient.addColorStop(1, '#222222');
                            ctx.fillStyle = gradient;

                            // Irregular asteroid shape
                            ctx.beginPath();
                            const sides = 6 + (mazeX + y) % 3;
                            const rotation = ((mazeX * y * 123) % 360) * Math.PI / 180;
                            for (let i = 0; i < sides; i++) {
                                const angle = (i / sides) * Math.PI * 2 + rotation;
                                const variance = 0.7 + ((mazeX * i + y) % 100) / 300;
                                const radius = (size / 2) * variance;
                                const px = screenX + Math.cos(angle) * radius;
                                const py = screenY + Math.sin(angle) * radius;
                                if (i === 0) {
                                    ctx.moveTo(px, py);
                                } else {
                                    ctx.lineTo(px, py);
                                }
                            }
                            ctx.closePath();
                            ctx.fill();

                            // Crater details
                            ctx.shadowBlur = 0;
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                            const craterCount = 2 + (mazeX + y) % 2;
                            for (let i = 0; i < craterCount; i++) {
                                const craterAngle = ((i * 137 + mazeX * y) % 360) * Math.PI / 180;
                                const craterDist = ((mazeX + y + i) % 5) * 2;
                                const craterX = screenX + Math.cos(craterAngle) * craterDist;
                                const craterY = screenY + Math.sin(craterAngle) * craterDist;
                                const craterSize = 2 + ((mazeX + y + i) % 3);
                                ctx.beginPath();
                                ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                                ctx.fill();
                            }

                            // Highlight for 3D effect
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                            ctx.beginPath();
                            ctx.arc(screenX - 3, screenY - 3, size * 0.2, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.restore();
                        }
                    }
                }
            }

            // Draw space collectibles (energy crystals)
            for (let fruit of fruits) {
                let screenX = (fruit.x * GRID_SIZE) - cameraOffset + GRID_SIZE / 2;
                let screenY = fruit.y * GRID_SIZE + GRID_SIZE / 2;
                if (screenX > -GRID_SIZE && screenX < canvasWidth) {
                    // Rotating crystal effect
                    const rotation = (currentTime / 500) % (Math.PI * 2);
                    const pulse = Math.sin(currentTime / 200) * 0.2 + 1;

                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(rotation);
                    ctx.scale(pulse, pulse);

                    // Outer glow
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = fruit.type === 0 ? '#ff00ff' : fruit.type === 1 ? '#00ffff' : '#ffff00';

                    // Crystal shape (diamond)
                    const crystalColors = ['#ff00ff', '#00ffff', '#ffff00'];
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, GRID_SIZE * 0.4);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.5, crystalColors[fruit.type]);
                    gradient.addColorStop(1, crystalColors[fruit.type] + '00');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -GRID_SIZE * 0.35);
                    ctx.lineTo(GRID_SIZE * 0.25, 0);
                    ctx.lineTo(0, GRID_SIZE * 0.35);
                    ctx.lineTo(-GRID_SIZE * 0.25, 0);
                    ctx.closePath();
                    ctx.fill();

                    // Inner bright core
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, GRID_SIZE * 0.1, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();

                    // Floating sparkle particles
                    if (Math.random() < 0.1) {
                        particleSystem.emit(
                            fruit.x * GRID_SIZE + cameraOffset,
                            fruit.y * GRID_SIZE + GRID_SIZE / 2,
                            (Math.random() - 0.5) * 0.5,
                            (Math.random() - 0.5) * 0.5,
                            20 + Math.random() * 10,
                            2,
                            crystalColors[fruit.type],
                            'star'
                        );
                    }
                }
            }

            // Draw particles
            particleSystem.draw(ctx, cameraOffset);

            // Draw Rockets
            for (let r of rockets) {
                r.draw(ctx, cameraOffset);
            }

            // Draw Boss
            if (bossActive) {
                boss.draw(ctx, cameraOffset);
            }

            // Draw Damage Texts
            for (let dt of damageTexts) {
                dt.draw(ctx, cameraOffset);
            }

            // Draw Ammo UI
            if (bossActive || distanceTraveled > distToBoss - 500) { // Show when near boss
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(10, canvasHeight - 60, 160, 50);

                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.fillText("ROCKETS:", 20, canvasHeight - 30);

                for (let i = 0; i < maxAmmo; i++) {
                    ctx.fillStyle = i < playerAmmo ? '#ff3300' : '#444';
                    ctx.beginPath();
                    ctx.arc(100 + i * 20, canvasHeight - 35, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            // Draw UFOs
            drawUFO(snake1, currentTime);
            if (gameMode === 'multiplayer' || gameMode === 'bot') {
                drawUFO(snake2, currentTime);
            }

            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(GRID_SIZE * 3, 0);
            ctx.lineTo(GRID_SIZE * 3, canvasHeight);
            ctx.stroke();
            ctx.setLineDash([]);

            // Restore screen shake transform
            ctx.restore();
        }

        function drawUFO(ufo, time) {
            if (!ufo.alive) return;

            // Apply blinking effect if invulnerable
            let alpha = 1.0;
            if (isInvulnerable(ufo)) {
                alpha = Math.sin(Date.now() / 100) * 0.35 + 0.65;
            }

            // Update UFO animation properties
            ufo.bobOffset = Math.sin(time / 300) * 2;
            ufo.tiltAngle = ufo.direction.x * 0.1 + ufo.direction.y * 0.15;

            // Draw thruster/tractor beam particles
            if (ufo.body.length > 0) {
                const head = ufo.body[0];
                const headScreenX = (head.x * GRID_SIZE) - cameraOffset + GRID_SIZE / 2;
                const headScreenY = head.y * GRID_SIZE + GRID_SIZE / 2 + ufo.bobOffset;

                // Emit tractor beam particles
                if (Math.random() < 0.3) {
                    const beamColor = ufo.color + '80';
                    particleSystem.emit(
                        headScreenX + cameraOffset,
                        headScreenY + 8,
                        (Math.random() - 0.5) * 0.5,
                        Math.random() * 1.5 + 0.5,
                        15 + Math.random() * 10,
                        2 + Math.random() * 2,
                        beamColor,
                        'circle'
                    );
                }
            }

            // Draw body trail segments (energy orbs)
            for (let i = ufo.body.length - 1; i > 0; i--) {
                let segment = ufo.body[i];
                let screenX = (segment.x * GRID_SIZE) - cameraOffset + GRID_SIZE / 2;
                let screenY = segment.y * GRID_SIZE + GRID_SIZE / 2;

                if (screenX > -GRID_SIZE && screenX < canvasWidth) {
                    const segmentAlpha = alpha * (1 - (i / ufo.body.length) * 0.5);
                    const segmentSize = (GRID_SIZE * 0.6) * (1 - (i / ufo.body.length) * 0.3);

                    // Glow effect
                    ctx.save();
                    ctx.globalAlpha = segmentAlpha * 0.3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = ufo.color;
                    ctx.fillStyle = ufo.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, segmentSize * 1.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    // Core energy orb
                    ctx.save();
                    ctx.globalAlpha = segmentAlpha;
                    const gradient = ctx.createRadialGradient(
                        screenX, screenY, 0,
                        screenX, screenY, segmentSize
                    );
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, ufo.color);
                    gradient.addColorStop(1, ufo.color + '00');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, segmentSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Draw UFO head (main saucer)
            if (ufo.body.length > 0) {
                const head = ufo.body[0];
                const screenX = (head.x * GRID_SIZE) - cameraOffset + GRID_SIZE / 2;
                const screenY = head.y * GRID_SIZE + GRID_SIZE / 2 + ufo.bobOffset;

                if (screenX > -GRID_SIZE && screenX < canvasWidth) {
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.translate(screenX, screenY);
                    ctx.rotate(ufo.tiltAngle);

                    // Outer glow
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = ufo.color;

                    // Bottom saucer plate
                    ctx.fillStyle = ufo.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 2, GRID_SIZE * 0.5, GRID_SIZE * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Middle band (metallic rim)
                    const rimGradient = ctx.createLinearGradient(0, -2, 0, 2);
                    rimGradient.addColorStop(0, '#666666');
                    rimGradient.addColorStop(0.5, '#aaaaaa');
                    rimGradient.addColorStop(1, '#666666');
                    ctx.fillStyle = rimGradient;
                    ctx.fillRect(-GRID_SIZE * 0.55, -2, GRID_SIZE * 1.1, 4);

                    // Top dome
                    const domeGradient = ctx.createRadialGradient(0, -4, 0, 0, -4, GRID_SIZE * 0.35);
                    domeGradient.addColorStop(0, '#ffffff');
                    domeGradient.addColorStop(0.3, ufo.color + 'cc');
                    domeGradient.addColorStop(1, ufo.color);
                    ctx.fillStyle = domeGradient;
                    ctx.beginPath();
                    ctx.ellipse(0, -4, GRID_SIZE * 0.35, GRID_SIZE * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Dome window/cockpit
                    ctx.fillStyle = 'rgba(100, 200, 255, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(0, -5, GRID_SIZE * 0.2, GRID_SIZE * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Alien pilot eyes (cartoony)
                    ctx.fillStyle = 'rgba(50, 255, 100, 0.8)';
                    ctx.beginPath();
                    ctx.arc(-3, -5, 2, 0, Math.PI * 2);
                    ctx.arc(3, -5, 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Eye pupils
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-3, -5, 1, 0, Math.PI * 2);
                    ctx.arc(3, -5, 1, 0, Math.PI * 2);
                    ctx.fill();

                    // Blinking lights
                    const lightPhase = (time / 500) % 1;
                    if (lightPhase < 0.5) {
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(-GRID_SIZE * 0.4, 0, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    if (lightPhase > 0.3 && lightPhase < 0.8) {
                        ctx.fillStyle = '#00ff00';
                        ctx.beginPath();
                        ctx.arc(GRID_SIZE * 0.4, 0, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Tractor beam glow underneath
                    ctx.globalAlpha = alpha * 0.2;
                    const beamGradient = ctx.createRadialGradient(0, 8, 0, 0, 8, GRID_SIZE * 0.4);
                    beamGradient.addColorStop(0, ufo.color + 'ff');
                    beamGradient.addColorStop(1, ufo.color + '00');
                    ctx.fillStyle = beamGradient;
                    ctx.beginPath();
                    ctx.arc(0, 8, GRID_SIZE * 0.4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }
            }

            ctx.globalAlpha = 1.0;
        }

        function gameLoop(currentTime) {
            if (!gameRunning) return;

            // Calculate deltaTime
            const now = performance.now();
            const deltaTime = now - lastFrameTime;
            lastFrameTime = now;

            // Update particles
            particleSystem.update(1);

            // Update screen shake
            updateScreenShake();

            // Handle resume countdown
            if (resumeCountdown > 0) {
                const elapsed = Date.now() - resumeCountdownStart;
                const remaining = 3 - Math.floor(elapsed / 1000);

                if (remaining <= 0) {
                    // Countdown zako≈Ñczony - wzn√≥w grƒô
                    resumeCountdown = 0;
                    gamePaused = false;
                } else {
                    // Rysuj countdown i pomi≈Ñ resztƒô logiki
                    draw();

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = 'bold 80px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#8af3ff';
                    ctx.fillText(remaining > 0 ? remaining : 'GO!', canvasWidth / 2, canvasHeight / 2);
                    ctx.shadowBlur = 0;

                    requestAnimationFrame(gameLoop);
                    return;
                }
            }

            // Je≈õli gra zapauzowana, rysuj tylko scenƒô (bez update)
            if (gamePaused) {
                draw();

                // Wy≈õwietl tekst "PAUZA"
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 60px Arial';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#8af3ff';
                ctx.fillText('PAUZA', canvasWidth / 2, canvasHeight / 2);
                ctx.shadowBlur = 0;

                requestAnimationFrame(gameLoop);
                return;
            }

            // Check camera delay
            const elapsedTime = Date.now() - gameStartTime;
            if (!cameraStarted && elapsedTime >= CAMERA_DELAY) {
                cameraStarted = true;
            }

            // Update snake1 based on its individual speed
            const snake1UpdateInterval = baseSnakeUpdateInterval / snake1.speed;
            if (currentTime - lastUpdateTime1 >= snake1UpdateInterval) {
                updateSnake(snake1);
                lastUpdateTime1 = currentTime;
                document.getElementById('score1').textContent = snake1.score;
            }

            // Update snake2 based on its individual speed (multiplayer and bot mode)
            if (gameMode === 'multiplayer' || gameMode === 'bot') {
                // Je≈õli bot, najpierw aktualizuj AI
                if (gameMode === 'bot') {
                    updateBotAI(snake2, currentTime);
                }

                const snake2UpdateInterval = baseSnakeUpdateInterval / snake2.speed;
                if (currentTime - lastUpdateTime2 >= snake2UpdateInterval) {
                    updateSnake(snake2);
                    lastUpdateTime2 = currentTime;
                    document.getElementById('score2').textContent = snake2.score;
                }

                // Check collisions between snakes (multiplayer and bot mode)
                if (snake1.alive && snake2.alive) {
                    const head1 = snake1.body[0];
                    const head2 = snake2.body[0];

                    // Check if snake1 head hit snake2 body (only if snake1 not invulnerable)
                    if (!isInvulnerable(snake1)) {
                        for (let segment of snake2.body) {
                            if (Math.floor(head1.x) === Math.floor(segment.x) && head1.y === segment.y) {
                                snake1.lives--;
                                updateLivesDisplay();
                                if (snake1.lives > 0) {
                                    makeInvulnerable(snake1);
                                } else {
                                    snake1.alive = false;
                                }
                                break;
                            }
                        }
                    }

                    // Check if snake2 head hit snake1 body (only if snake2 not invulnerable)
                    if (!isInvulnerable(snake2)) {
                        for (let segment of snake1.body) {
                            if (Math.floor(head2.x) === Math.floor(segment.x) && head2.y === segment.y) {
                                snake2.lives--;
                                updateLivesDisplay();
                                if (snake2.lives > 0) {
                                    makeInvulnerable(snake2);
                                } else {
                                    snake2.alive = false;
                                }
                                break;
                            }
                        }
                    }
                }
            }

            // Move camera only after delay
            if (cameraStarted) {
                // 1. Calculate base speed (pixels per ms)
                // Track and remember the maximum speed achieved
                let currentMaxSpeed = 1.0;
                if (snake1.alive) currentMaxSpeed = Math.max(currentMaxSpeed, snake1.speed);
                if (gameMode === 'multiplayer' && snake2.alive) currentMaxSpeed = Math.max(currentMaxSpeed, snake2.speed);

                // Only increase speed, never decrease
                maxSpeedAchieved = Math.max(maxSpeedAchieved, currentMaxSpeed);
                let maxSnakeSpeed = maxSpeedAchieved;

                const baseSpeedPxPerMs = (maxSnakeSpeed * GRID_SIZE) / baseSnakeUpdateInterval;

                // 2. Calculate target position (fastest player at 35% of screen)
                // Track current max player position
                let currentMaxPlayerX = 0;
                if (snake1.alive) currentMaxPlayerX = Math.max(currentMaxPlayerX, snake1.body[0].x * GRID_SIZE);
                if (gameMode === 'multiplayer' && snake2.alive) currentMaxPlayerX = Math.max(currentMaxPlayerX, snake2.body[0].x * GRID_SIZE);

                // Only move forward, never backward
                maxProgressX = Math.max(maxProgressX, currentMaxPlayerX);
                let maxPlayerX = maxProgressX;

                const targetScreenX = canvasWidth * 0.35;
                const currentScreenX = maxPlayerX - cameraOffset;

                // 3. Calculate movement with catch-up logic
                let moveAmount = baseSpeedPxPerMs * deltaTime;

                // Apply correction if player is drifting
                const error = currentScreenX - targetScreenX;
                const correctionFactor = 0.005; // Adjust for responsiveness
                moveAmount += error * correctionFactor * deltaTime;

                // Prevent moving backwards but keep minimum speed
                const minSpeed = baseSpeedPxPerMs * deltaTime * 0.3; // 30% of base speed
                if (moveAmount < minSpeed) moveAmount = minSpeed;

                cameraOffset += moveAmount;
                distanceTraveled = cameraOffset;
            }

            const currentColumn = Math.floor(cameraOffset / GRID_SIZE);
            if (currentColumn + COLS + 20 > lastGeneratedColumn) {
                for (let x = lastGeneratedColumn; x < lastGeneratedColumn + 10; x++) {
                    generateMazeColumn(x);
                }
                lastGeneratedColumn += 10;
            }

            // BOSS BATTLE LOGIC
            // Reload Ammo
            if (playerAmmo < maxAmmo) {
                if (Date.now() - lastRocketReload > 3000) {
                    playerAmmo++;
                    lastRocketReload = Date.now();
                }
            }

            // Spawn Boss
            if (!bossActive && distanceTraveled > distToBoss) { // Trigger at distance
                boss.spawn(cameraOffset);
            }

            // Update Boss
            if (bossActive) {
                boss.update(cameraOffset);
                if (boss.hp <= 0) {
                    bossActive = false;
                    boss.state = 'dead';
                    // Reward
                    totalCoins += 500;
                    // Explosion effect (can add later)
                    distToBoss += 5000; // Next boss further away
                }
            }

            // Update Rockets
            for (let i = rockets.length - 1; i >= 0; i--) {
                const r = rockets[i];
                r.update();
                if (!r.active) {
                    rockets.splice(i, 1);
                    continue;
                }

                // Collision Rocket vs Boss
                if (bossActive && boss.state !== 'dead') {
                    // Simple box collision relative to screen
                    // Boss is drawn at boss.x - cameraOffset, boss.y
                    // Rocket is at r.x - cameraOffset, r.y
                    // We can check absolute coordinates though
                    const bossScreenX = boss.x;
                    const bossScreenY = boss.y;

                    if (Math.abs(r.x - bossScreenX) < 80 && Math.abs(r.y - bossScreenY) < 80) {
                        boss.hp -= 5; // 20 hits to kill
                        r.active = false;
                        rockets.splice(i, 1);

                        // Hit effect
                        for (let k = 0; k < 5; k++) {
                            particleSystem.emit(r.x, r.y, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, 10, 2, '#ff0000', 'circle');
                        }
                    }
                }
            }


            // Check if snakes fell behind camera (only if not invulnerable)
            if (snake1.alive && !isInvulnerable(snake1) && snake1.body[0].x * GRID_SIZE < cameraOffset - GRID_SIZE) {
                snake1.lives--;
                updateLivesDisplay();
                if (snake1.lives > 0) {
                    makeInvulnerable(snake1);
                } else {
                    snake1.alive = false;
                }
            }

            if (gameMode === 'multiplayer' && snake2.alive && !isInvulnerable(snake2) && snake2.body[0].x * GRID_SIZE < cameraOffset - GRID_SIZE) {
                snake2.lives--;
                updateLivesDisplay();
                if (snake2.lives > 0) {
                    makeInvulnerable(snake2);
                } else {
                    snake2.alive = false;
                }
            }

            // End game conditions
            if (gameMode === 'solo' || gameMode === 'boss') {
                if (!snake1.alive) {
                    endGame();
                    return;
                }
            } else {
                // Multiplayer: end when both snakes have no lives
                if (!snake1.alive && !snake2.alive) {
                    endGame();
                    return;
                }
            }

            draw();

            // Draw countdown
            if (!cameraStarted) {
                const remaining = Math.ceil((CAMERA_DELAY - elapsedTime) / 1000);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(remaining > 0 ? remaining : 'GO!', canvasWidth / 2, canvasHeight / 2);
            }

            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameRunning = false;

            let winnerText = '';
            let earnedCoins = 0;

            if (gameMode === 'solo' || gameMode === 'boss') {
                // Solo / Boss mode
                earnedCoins = Math.floor(snake1.score / 10);
                totalCoins += earnedCoins;

                winnerText = 'üíÄ Game Over! üíÄ';

                // Check high score for solo
                const soloHighScore = parseInt(localStorage.getItem('snakeSoloHighScore') || '0');
                if (snake1.score > soloHighScore) {
                    localStorage.setItem('snakeSoloHighScore', snake1.score.toString());
                    winnerText += ' üéâ NEW RECORD! üéâ';
                }

                document.getElementById('finalScore1').textContent = snake1.score;
                document.getElementById('finalScore2').parentElement.style.display = 'none';
            } else {
                // Multiplayer or Bot mode
                earnedCoins = Math.floor((snake1.score + snake2.score) / 10);
                totalCoins += earnedCoins;

                const totalScore = snake1.score + snake2.score;

                if (gameMode === 'bot') {
                    // Bot mode - specific messages for bot
                    if (snake1.alive && !snake2.alive) {
                        winnerText = 'üéâ You Won! Bot Defeated! üéâ';
                    } else if (snake2.alive && !snake1.alive) {
                        winnerText = 'üíî Bot Won! Try Again! üíî';
                    } else if (!snake1.alive && !snake2.alive) {
                        // Both died, check who has more points
                        if (snake1.score > snake2.score) {
                            winnerText = 'üéâ You Won on Points! üéâ';
                        } else if (snake2.score > snake1.score) {
                            winnerText = 'üíî Bot Won on Points! üíî';
                        } else {
                            winnerText = 'ü§ù Draw! ü§ù';
                        }
                    }
                } else {
                    // Multiplayer mode
                    if (snake1.alive && !snake2.alive) {
                        winnerText = 'üèÜ Player 1 Wins! üèÜ';
                    } else if (snake2.alive && !snake1.alive) {
                        winnerText = 'üèÜ Player 2 Wins! üèÜ';
                    } else if (!snake1.alive && !snake2.alive) {
                        // Both died, check who has more points
                        if (snake1.score > snake2.score) {
                            winnerText = 'üèÜ Player 1 Wins! (More Points) üèÜ';
                        } else if (snake2.score > snake1.score) {
                            winnerText = 'üèÜ Player 2 Wins! (More Points) üèÜ';
                        } else {
                            winnerText = 'ü§ù Draw! ü§ù';
                        }
                    }
                }

                // Check high score for multiplayer
                if (totalScore > highScore) {
                    highScore = totalScore;
                    winnerText += ' üéâ NEW RECORD! üéâ';
                }

                document.getElementById('finalScore1').textContent = snake1.score;
                document.getElementById('finalScore2').textContent = snake2.score;
                document.getElementById('finalScore2').parentElement.style.display = 'block';
            }

            saveProgress();

            // Check for leaderboard qualification
            const finalScore = gameMode === 'solo' ? snake1.score : (snake1.score + snake2.score);
            if (isHighScore(finalScore)) {
                // Show name entry modal first, then game over screen
                showNameEntryModal(finalScore, gameMode === 'solo' ? 'solo' : 'multiplayer');
            }

            document.getElementById('winnerText').textContent = winnerText;
            document.getElementById('earnedCoins').textContent = earnedCoins;
            document.getElementById('gameOver').style.display = 'block';
        }

        document.addEventListener('keydown', (e) => {
            // Q - Exit to menu
            if (e.key === 'q' || e.key === 'Q') {
                if (gameRunning) {
                    exitToMenu();
                }
                return;
            }

            if (!gameRunning) return;

            // WASD - Gracz 1
            if (e.key === 'w' || e.key === 'W') {
                snake1.nextDirection = { x: 0, y: -1 };
            } else if (e.key === 's' || e.key === 'S') {
                snake1.nextDirection = { x: 0, y: 1 };
            } else if (e.key === 'a' || e.key === 'A') {
                snake1.nextDirection = { x: -1, y: 0 };
            } else if (e.key === 'd' || e.key === 'D') {
                snake1.nextDirection = { x: 1, y: 0 };
            }

            // Strza≈Çki - Gracz 2 (only in multiplayer)
            if (gameMode === 'multiplayer') {
                if (e.key === 'ArrowUp') {
                    snake2.nextDirection = { x: 0, y: -1 };
                    e.preventDefault();
                } else if (e.key === 'ArrowDown') {
                    snake2.nextDirection = { x: 0, y: 1 };
                    e.preventDefault();
                } else if (e.key === 'ArrowLeft') {
                    snake2.nextDirection = { x: -1, y: 0 };
                    e.preventDefault();
                } else if (e.key === 'ArrowRight') {
                    snake2.nextDirection = { x: 1, y: 0 };
                    e.preventDefault();
                }
            }
        });

        // Event listeners dla przycisk√≥w confirmation modal
        document.getElementById('confirmYes').addEventListener('click', () => {
            if (confirmCallback) {
                confirmCallback();
            }
            hideConfirmModal();
        });

        document.getElementById('confirmNo').addEventListener('click', () => {
            hideConfirmModal();
        });

        // Audio controls initialization
        const muteToggle = document.getElementById('muteToggle');
        const backgroundMusic = document.getElementById('backgroundMusic');

        // Set initial volume
        backgroundMusic.volume = 0.5;

        // Handle mute toggle
        muteToggle.addEventListener('click', function () {
            backgroundMusic.muted = !backgroundMusic.muted;
            const muteIcon = this.querySelector('.mute-icon');

            if (backgroundMusic.muted) {
                muteIcon.textContent = 'üîá';
                this.classList.add('muted');
            } else {
                muteIcon.textContent = 'üîä';
                this.classList.remove('muted');
            }
        });

        // Handle game mode change - show/hide bot difficulty selector
        document.getElementById('gameModeSelect').addEventListener('change', function () {
            const botDifficultyContainer = document.getElementById('botDifficultyContainer');
            if (this.value === 'bot') {
                botDifficultyContainer.style.display = 'block';
            } else {
                botDifficultyContainer.style.display = 'none';
            }
        });

        // Inicjalizacja
        (async () => {
            await loadLeaderboard();
            console.log('Game initialized with leaderboard');
        })();
        updateCoinDisplay();
        draw();
    </script>

    <!-- Background Music -->
    <audio id="backgroundMusic" loop>
        <source src="10.8s Recording (27 Nov @ 10_17) (Remix).mp3" type="audio/mpeg">
    </audio>
</body>

</html>